# 2667. 단지번호붙이기

## 단지수를 출력하고, 각 단지에 속하는 집의 수를 오름차순으로 정렬하기

#### [2667. 단지번호붙이기][https://www.acmicpc.net/problem/2667]

- 정사각형 모양의 지도에서 1은 집이 있는 곳을, 0은 집이 없는 곳을 나타낸다. 
- 연결된 집의 모임인 단지를 정의하고, 단지에 번호를 붙인다.
- 연결되었다는 것은 좌우, 아래위로 다른 집이 있는 경우이다.
-  대각선상에 집이 있는 경우는 연결된 것이 아니다.

---

## Idea

- dfs 깊이 우선 탐색을 사용한다.
- 집이 있는 곳을 만나면 4방향 탐색을 진행하여 또 집이 있는 곳을 찾아 반복 진행한다.
- 방문체크를 진행할 때 마다 카운트를 센다.

---

## Problem

1. `IndexError : list index out of range` 발생

   ```python
    if 0 <= ni < n and 0 <= nj < n and arr[ni][nj] and visited[ni][nj] == 0:
   ```

   - `arr` 의 입력을 잘 못 받음

   ```python
   # 0110100
   
   arr = [list(map(int, input().split())) for _ in range(n)]
   
   # [[110100], [110101], [1110101], [111], [100000], [111110], [111000]]
   ```

2. 각 단지내 집의 수 다름

   ```python
   def dfs(i, j):
       global visited
       global cnt_s
       visited[i][j] = 1    # 방문 체크
       cnt_s += 1
       for k in range(4):
           ni = i + di[k]
           nj = j + dj[k]
           if 0 <= ni < n and 0 <= nj < n and arr[ni][nj] and visited[ni][nj] == 0:
               # visited[ni][nj] = 1  # 방문 체크
               # cnt_s += 1
               dfs(ni, nj)
       return cnt_s
   
   # [13, 15, 17]
   ```

   - 재귀함수로 연결되는 데 연결되기 전에 방문 체크를 한번 더 넣어서 방문 체크가 중복된다.  `visited[ni][nj] = 1` 

---

## Revision

1. 입력 수정

   ```python
   arr = [list(map(int, input())) for _ in range(n)]
   
   # [[0, 1, 1, 0, 1, 0, 0], [0, 1, 1, 0, 1, 0, 1], [1, 1, 1, 0, 1, 0, 1], [0, 0, 0, 0, 1, 1, 1], [0, 1, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 0, 0, 0]]
   ```

2. 방문 체크 수정

   ```python
   def dfs(i, j):
       global visited
       global cnt_s
       visited[i][j] = 1    # 방문 체크
       cnt_s += 1
       for k in range(4):
           ni = i + di[k]
           nj = j + dj[k]
           if 0 <= ni < n and 0 <= nj < n and arr[ni][nj] and visited[ni][nj] == 0:
               dfs(ni, nj)
       return cnt_s
   
   # [7, 8, 9]
   ```

---

## Code

```python
def dfs(i, j):
    global visited
    global cnt_s
    visited[i][j] = 1               # 방문 체크
    cnt_s += 1                      # 각 단지내 집의 수
    for k in range(4):              # 4방향 탐색
        ni = i + di[k]
        nj = j + dj[k]
        if 0 <= ni < n and 0 <= nj < n and arr[ni][nj] and visited[ni][nj] == 0:
            # visited[ni][nj] = 1   # 방문 체크
            # cnt_s += 1
            dfs(ni, nj)             # 다시 탐색
    return cnt_s


n = int(input())
arr = [list(map(int, input())) for _ in range(n)]

visited = [[0] * n for _ in range(n)]

di = [0, 1, 0, -1]                  # 우하좌상
dj = [1, 0, -1, 0]

cnt_b = 0                           # 총 단지수
cnt = []

for i in range(n):
    for j in range(n):
        if arr[i][j] and visited[i][j] == 0:
            cnt_b += 1              # 총 단지수
            cnt_s = 0               # 각 단지내 집의 수 초기화
            cnt.append(dfs(i,j))    # 각 단지내 집의 수 추가

print(cnt_b)
cnt.sort()
for z in cnt:
    print(z)
```

---

## Comment

- **입력 값 똑바로 보기**

