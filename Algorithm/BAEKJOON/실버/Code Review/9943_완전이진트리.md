# 9934. 완전 이진 트리

## 상근이가 빌딩에 들어간 순서대로, 각 레벨에 있는 빌딩의 번호를 구하기

#### [9934. 완전 이진 트리](https://www.acmicpc.net/problem/9934)

- 깊이가 K인 완전 이진 트리는 총 2K-1개의 노드로 이루어져 있다.

- 각 노드에는 그 곳에 위치한 빌딩의 번호가 붙여져 있다.

- 가장 마지막 레벨을 제외한 모든 집은 왼쪽 자식과 오른쪽 자식을 갖는다.

- 가장 처음에 상근이는 트리의 루트에 있는 빌딩 앞에 서있다.

- 현재 빌딩의 왼쪽 자식에 있는 빌딩에 아직 들어가지 않았다면, 왼쪽 자식으로 이동한다.

- 현재 있는 노드가 왼쪽 자식을 가지고 있지 않거나 왼쪽 자식에 있는 빌딩을 이미 들어갔다면, 현재 노드에 있는 빌딩을 들어가고 종이에 번호를 적는다.

- 현재 빌딩을 이미 들어갔다 온 상태이고, 오른쪽 자식을 가지고 있는 경우에는 오른쪽 자식으로 이동한다.

- 현재 빌딩과 왼쪽, 오른쪽 자식에 있는 빌딩을 모두 방문했다면, 부모 노드로 이동한다.

  ![9934_완전이진트리](https://user-images.githubusercontent.com/109335452/190840525-1a4754b8-3d35-4c71-aa09-2700687137ee.jpg)

- 그림에 나와있는 마을이라면, 

  - 왼쪽 그림의 경우에는 2-1-3 순서대로 빌딩을 들어갔을 것
  - 오른쪽 그림의 경우에는 1-6-4-3-5-2-7 순서로 들어갔을 것

---

## Idea

- 완전이진트리
- 서브트리끼리 전위 순회를 하면 부모노드를 레벨 순으로 얻을 수 있다. (V → L  → R)
- 중위순회의 결과이므로 중간에 루트가 온다
- 루트를 기준으로 오른쪽, 왼쪽 서버트리를 전위 순회하면서 레벨을 준다. 


---

## Problem

1. 서브트리끼리의 전위순위를 생각해 내는데 오랜시간이 걸림

2. 레벨을 구분할 수 있게  장치를 달아줘야한다.

3. 함수에서 전위 순회할 범위 정하기

   ```python
   def mid_node(arr):
       mid = len(arr)//2
       if mid:
           # 전위순회
   print(mid_node(arr))		# [3, 6, 2]
   ```


---

## Revision

2. 레벨끼리 구분할 수 있게 함수에 인자를 추가함

3. 레벨을 구분하는 인자를 전위순회의 범위로 준다.

   ```python
   def mid_node(level, arr):
       global num
       mid = len(arr)//2
       if k > level:
           # 전위순회
   ```


---

## Code

```python
def mid_node(level, arr):   			 # 부모 노드와 오른쪽,왼쪽 서브트리가 전위 순회를 한다고 생각
    global num
    mid = len(arr)//2
    if k > level:
        num[level].append(arr[mid])    	 # 레벨을 인덱스로 구분
        mid_node(level+1, arr[:mid])
        mid_node(level+1, arr[mid+1:])

k = int(input())
arr = list(map(int, input().split()))
num = [[]*k for _ in range(k)]

mid_node(0, arr)
for i in range(k):
    print(*num[i])
```

---

## Comment

- 문제를 읽고 **어떤 방법으로 알고리즘을 구현할지 생각하기!**
- **tree** 공부하기
