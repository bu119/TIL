# 1149. RGB거리

##  아래의 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값 구하기

#### [1149. RGB거리](https://www.acmicpc.net/problem/1149)

- RGB거리에는 집이 N개 있다. 
- 집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다.
- 규칙
  - 1번 집의 색은 2번 집의 색과 같지 않아야 한다.
  - N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.
  - i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.

---

## Idea

- DP 의 Top - Down 방식으로 구현
  - 큰 문제에서 작은 부분문제를 재귀적으로 호출
- 현재  행에서 인덱스를 선택하고 이전 행에서 선택한 인덱스를 제외한 값들의 최소값을 찾는다.
- 모든 경우의 수를 탐색하여 최소값의 누적 합을 구하여 비교한다.

---

## Problem

1.  DP의 Top-Down 방식을 이용하면 문제를 쉽게 해결할 수 있는 데 Bottom-Up 방식을 생각하여 복잡한 방법으로 코드 구현을 시도함
2. 각 인덱스를 선택하고 선택한 인덱스를 제외한 이전 행의 값들을 함수 min으로  비교하여 누적 합으로 문제를 쉽게 해결할 수 있는데
3. DP를 인지하였으나 코드를 간단하게 구현하지 못했고 min함수를 제대로 활용하지 못하고 어렵게 생각하여 문제를 복잡하게 풀이함

---

## Revision

1. DP의 Top-Down 방식으로 간단하게 코드를 구현

   ```python
   house[i][0] += min(house[i-1][1], house[i-1][2])
   house[i][1] += min(house[i-1][0], house[i-1][2])
   house[i][2] += min(house[i-1][0], house[i-1][1])
   ```

---

## Code

```python
n = int(input())
house = [list(map(int, input().split())) for _ in range(n)]

for i in range(1, n):
    house[i][0] += min(house[i-1][1], house[i-1][2])
    house[i][1] += min(house[i-1][0], house[i-1][2])
    house[i][2] += min(house[i-1][0], house[i-1][1])

print(min(house[n-1]))
```

---

## Learning

### Dynamic Programming (동적 계획법)

- 복잡한 문제를 여러 개의 작은 부분 문제(sub-problem)로 나누어 해결하는 문제 해결 기법
- 동적 계획법의 특징 중 하나는 이미 계산된 부분 문제가 다시 발생하면 새롭게 계산하지 않고 이전의 계산값을 참조하여 이용하는 것
- 이 방법은 시간을 절약할 수 있지만, 이전 계산값을 저장해둘 공간이 필요하므로 시간과 메모리의 trade-off라고 할 수 있다.

#### 1. Memoization

- 같은 파라미터를 가진 함수를 중복 호출은 굉장히 비효율적이며 이를 해결할 수 있는 것이 Memoization이다.
- Memoization이란 한 번 계산된 값을 기록해두고 이후 중복 호출되었을 때 저장해 둔 값을 가져와 사용하는 방법이다. 

#### 2. Top-Down와 Bottom-Up

- 동적 계획법의 구현은 크게 Top-Down방식과 Bottom-Up방식으로 나뉘어진다.

1. **Top-Down방식**
   - 큰 문제에서 작은 부분문제를 재귀적으로 호출하여 리턴 되는 값을 이용하여 큰 문제를 해결하는 방식
   - 중복되는 부분문제를 피하기 위해 앞서 소개한 Memoization기법을 함께 사용
2. **Bottom-Up방식**
   - 작은 부분문제들을 미리 계산해두고, 이 부분문제들을 모아 큰 문제를 해결하는 방식
   - 일반적으로 배열에 값을 채워나가는 형태로 구현
3. 장단점
   - Top-Down방식의 경우, 
     - 재귀함수를 통해 구현되므로 함수 호출에 대한 오버헤드가 발생한다. 
     - 큰 문제를 해결하기 위해 필요한 sub-problem만을 호출하므로 필요한 부분만 계산하게 되어 특정한 경우에는 Bottom-Up방식보다 빠르게 동작할 수 있다.
   - Bottom-Up방식의 경우,
     - 반복문을 통해 구현되므로 이러한 자원에 비교적 자유로워 시간 및 메모리의 최적화가 쉽다.
     - 큰 문제를 해결하기까지 어떠한 sub-problem이 요구되는지 알 수 없으므로 전체 문제를 계산하기 위해 모든 부분문제를 해결해야 한다.

---

## Comment

- **Dynamic Programming (동적 계획법) 공부하기**
- Top - Down / Bottom - Up 방식 이해하기