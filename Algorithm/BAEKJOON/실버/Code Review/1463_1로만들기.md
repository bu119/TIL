# 1463. 1로 만들기

## 연산 세 개를 사용하여 1을 만드는 연산 사용 횟수의 최솟값 출력하기

#### [1463. 1로 만들기](https://www.acmicpc.net/problem/1463)

정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

- X가 3으로 나누어 떨어지면, 3으로 나눈다.
- X가 2로 나누어 떨어지면, 2로 나눈다.
- 1을 뺀다.

---

## Idea

- DFS, BFS 둘다 아니고 DP로 구현
- 작은 수 들의 규칙을 찾아 큰 수에 적용

---

## Problem

1.  BFS를 활용하려 하였으나
   - `3`과 `2`로 나누어질 때 `-1`도 가능하므로 경우를 2가지로 나눠야한다.
   - BFS로 구현하는 방법을 모르겠어서 DFS로 변경
   
2.  dfs 인줄알았으나

    - 완전탐색으로 모든 경우의 수를 탐색하여 백트래킹으로 경우의 수를 줄이려 하였으나
- **DP로 구현**하는 방법이 더 간단하다는 것을 깨달음
  
3.  6으로 나누기가 가능할 때 2와 3 중에 먼저 나누는 수에 따라 경우의 수가 바뀌는 수가 존재함

    - n = 642일 때 
    - 2로 나누면 321이 나오고 정답은 10
    - 3으로 나누면 214이 나오고 정답은 11

    ```python
    if i % 3 == 0:
        arr[i] = min(arr[i // 3], arr[i - 1]) + 1  
    elif i % 2 == 0:
        arr[i] = min(arr[i // 2], arr[i - 1]) + 1    
    else:
        arr[i] = arr[i - 1] + 1  
    ```


---

## Revision

1. 6으로 나누기가 가능할 때 2와 3 중에 먼저 나누는 수에 따라 달라지는 경우의 수를 비교해 줘야한다.

   ```python
   if i % 6 == 0:                                      # 2와 3 먼저 나누는 수에 따라 경우의 수가 바뀜
          arr[i] = min(arr[i // 3], arr[i // 2], arr[i - 1]) + 1
   ```


---

## Code

```python
n = int(input())
arr = [0] * (n + 1)
for i in range(2, n + 1):

    if i % 6 == 0:                                      # 2와 3 먼저 나누는 수에 따라 경우의 수가 바뀜
        arr[i] = min(arr[i // 3], arr[i // 2], arr[i - 1]) + 1
    elif i % 3 == 0:
        arr[i] = min(arr[i // 3], arr[i - 1]) + 1       # 바로 전 단계의 경우의 수와 나누기를 하고 난 뒤 나온 수의 경우의 수를 비교 해야한다.
    elif i % 2 == 0:
        arr[i] = min(arr[i // 2], arr[i - 1]) + 1
    else:
        arr[i] = arr[i - 1] + 1                          # -1이 있으므로 바로 전 단계에서 +1을 한 경우의 수

print(arr[n])
```

---

## Comment

- 문제를 읽고 **어떤 방법으로 알고리즘을 구현할지 생각하기!**
- **`if` 문의 조건 설정 주의하기!!** (다양한 경우의 수 생각하기)
