# 3190. 뱀

## 사과의 위치와 뱀의 이동경로가 주어질 때, 게임이 몇 초에 끝나는지 계산하기

#### [3190. 뱀](https://www.acmicpc.net/problem/3190)

- 뱀이 나와서 기어다니는데, 사과를 먹으면 뱀 길이가 늘어난다.
- 뱀이 기어다니다가 벽 또는 자기자신의 몸과 부딪히면 게임이 끝난다.
- 게임은 NxN 정사각 보드위에서 진행되고, 몇몇 칸에는 사과가 놓여져 있다.
- 게임이 시작할때 뱀은 맨위 맨좌측에 위치하고 뱀의 길이는 1 이다.
- 뱀은 처음에 오른쪽을 향한다.
- 뱀은 매 초마다 이동을 하는데 다음과 같은 규칙을 따른다.
  - 먼저 뱀은 몸길이를 늘려 머리를 다음칸에 위치시킨다.
  - 만약 이동한 칸에 사과가 있다면, 그 칸에 있던 사과가 없어지고 꼬리는 움직이지 않는다.
  - 만약 이동한 칸에 사과가 없다면, 몸길이를 줄여서 꼬리가 위치한 칸을 비워준다. 즉, 몸길이는 변하지 않는다.

---

## Idea

- 네방향 탐색(동남서북)으로 오른쪽, 왼쪽 방향 전환 
- 사과에 도달했을 길이 늘려주며 사과 제거
- 뱀의 위치 저장
- 방향전환이 끝나고도 직진

---

## Problem

1.  2번 예제 케이스가 이해되지 않음

---

## Revision

1. 방향 전환이 끝나고 벽이나 몸에 닿을 때 까지 계속 직진


---

## Code

```python
def snake():
    time = 0                # 시간
    posi = [(0,0)]          # 뱀 위치
    row = col = 0           # 뱀 머리 좌표
    idx = 0                 # 4방향 탐색할 인덱스
    r = di[0]               # 이동 할 행 방향
    c = dj[0]               # 이동 할 열 방향
    flag = 1
    while flag:
        if sec:
            for z in range(sec.pop(0)):
                row += r
                col += c
                time += 1
                if 0 <= row < n and 0 <= col < n and (row, col) not in posi: # 벽체크, 자신과 안만남
                    pass
                else:
                    flag = 0
                    break

                if board[row][col]:         # 사과
                    board[row][col] = 0     # 먹어서 없어짐
                    posi.append((row, col)) # 머리 넣기
                else:
                    posi.pop(0)             # 새로운 꼬리 넣기
                    posi.append((row, col))

            if flag == 0:
                break

            if dire.pop(0) == 'D':			# 방향 전환
                idx = (idx + 1) % 4
                r = di[idx]
                c = dj[idx]
            else:
                idx = (idx - 1) % 4
                r = di[idx]
                c = dj[idx]
        else:                   # 방향 전환이 끝나고 벽 or 몸에 닿을 때 까지
            row += r
            col += c
            time += 1
            if 0 <= row < n and 0 <= col < n and (row, col) not in posi:  # 벽체크, 자신과 안만남
                pass
            else:
                flag = 0
                break
    return time

n = int(input())
board = [[0]*n for _ in range(n)]
apple = int(input())
for i in range(apple):
    x, y = map(int, input().split())
    board[x-1][y-1] = 1

sec = []
dire = []
num = int(input())
for j in range(num):
    s, d = input().split()
    dire.append(d)
    sec.append(int(s))

for k in range(num-1,0,-1):
    sec[k] -= sec[k-1]

di = [0, 1, 0, -1]   # 우하좌상
dj = [1, 0, -1, 0]

print(snake())
```

---

## Comment

- 문제를 읽고 **어떤 방법으로 알고리즘을 구현할지 생각하기!**
- dfs, bfs 등의 문제를 풀다가 푸니까 그리디하게 풀기 어렵다.
- 코드를 구현 할 때 문제 해결 순서 주의하기
