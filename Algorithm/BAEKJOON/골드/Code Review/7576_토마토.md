# 7576. 토마토

## 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지, 최소 일수 구하기

#### [7576. 토마토](https://www.acmicpc.net/problem/7576)

- 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 
- 하나의 토마토의 인접한 곳은 왼쪽, 오른쪽, 앞, 뒤 네 방향에 있는 토마토를 의미한다. 
- 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다.
- 모든 토마토가 익어있는 상태이면 0을 출력
- 토마토가 모두 익지는 못하는 상황이면 -1을 출력

---

## Idea

- bfs를 활용하여 네방향 탐색으로 넓혀나간다.
- 네방향 탐색으로 토마토를 변화시키고 카운트한다.
- 전체적으로 한번 탐색  때 마다 어떻게 카운트 할지 생각하는 것이 포인트!!!!

---

## Problem

1.  시간초과
   
   - 리스트(list) 대신 데크(deque)를 사용한다.
   - 데크(deque)는 양 끝 요소의 append와 pop이 압도적으로 빠르다.
   
   ```python
   def bfs(arr):
       q = []     		# List 
       
   	...
       
       while q:
           i, j = q.pop(0)
   ```

---

## Revision

1. 데크(deque)를 사용

   ```python
   from collections import deque
   
   def bfs(arr):
       q = deque()     # List 시간초과 - deque 사용
      
   	...
       
       while q:
           i, j = q.popleft()
   ```

   

---

## Code

```python
from collections import deque

def bfs(arr):
    q = deque()     # List 시간초과 - deque 사용
    cnt = -1        # 최소 일수
    f_top = 0       # 탐색할 스탭 개수
    s_top = 0       # 뻗어 나온 다음 탐색할 스탭 개수

    for i in range(n):
        for j in range(m):
            if arr[i][j] == 1:      # 토마토가 있는 자리를 q에 다 넣기
                q.append((i,j))
                f_top += 1
    while q:
        i, j = q.popleft()
        f_top -= 1                  # 앞에 스탭의 좌표를 탐색할 때 마다 개수를 -1
        for z in range(4):          # 4방향 탐색
            ni = i + di[z]
            nj = j + dj[z]
            if 0 <= ni < n and 0 <= nj < m and arr[ni][nj]==0:
                arr[ni][nj] = 1
                q.append((ni, nj))  # 다음 스탭의 좌표를 q에 넣어줌
                s_top += 1          # 다음 스탭의 개수를 추가
        if f_top == 0:              # 앞의 스탭 좌표를 다 꺼내면 개수를 다음 스탭과 바꿔줌
            f_top, s_top = s_top, f_top
            cnt += 1                # 하루가 지남

    return cnt


m, n = map(int, input().split())
arr = [list(map(int,input().split())) for _ in range(n)]

di = [0, 1, 0, -1]  # 우하좌상 탐색
dj = [1, 0, -1, 0]

flag = 0

cnt = bfs(arr)

for k in range(n):
    if 0 in arr[k]:
        flag = 1
        break

if flag:
    print(-1)
else:
    print(cnt)
```

---

## Learning

#### 데크(deque)

- 컨테이너(container)의 양끝 엘리먼트(element)에 접근하여 삽입 또는 제거를 할 경우, 
  - 일반적인 **리스트(list)가 이러한 연산에 O(n)**이 소요되는 데 반해, 
  - **데크(deque)는 O(1)**로 접근 가능하다.

- 데크(deque) 메서드(method)
  - `deque.append(item)`: item을 데크의 오른쪽 끝에 삽입한다.
  - `deque.appendleft(item)`: item을 데크의 왼쪽 끝에 삽입한다.
  - `deque.pop()`: 데크의 오른쪽 끝 엘리먼트를 가져오는 동시에 데크에서 삭제한다.
  - `deque.popleft()`: 데크의 왼쪽 끝 엘리먼트를 가져오는 동시에 데크에서 삭제한다.

---

## Comment

- 문제를 읽고 **어떤 방법으로 알고리즘을 구현할지 생각하기!**
- **불 필요한 탐색을 줄여 시간초과 조심하기!!!**

