# 16236. 아기상어

## 아기 상어가 엄마 상어에게 도움을 요청하지 않고 물고기를 잡아먹을 수 있는 시간 구하기

#### [16236. 아기상어](https://www.acmicpc.net/problem/16236)

- 아기 상어는 자신의 크기보다 큰 물고기가 있는 칸은 지나갈 수 없다.
- 아기 상어는 자신의 크기보다 작은 물고기만 먹을 수 있다. 
- 따라서, 크기가 같은 물고기는 먹을 수 없지만, 그 물고기가 있는 칸은 지나갈 수 있다.
- 더 이상 먹을 수 있는 물고기가 공간에 없다면 아기 상어는 엄마 상어에게 도움을 요청한다.
- 먹을 수 있는 물고기가 1마리보다 많다면, 거리가 가장 가까운 물고기를 먹으러 간다.
  - 거리는 아기 상어가 있는 칸에서 물고기가 있는 칸으로 이동할 때, 지나야하는 칸의 개수의 최솟값이다.
  - **거리가 가까운 물고기가 많다면, 가장 위에 있는 물고기, 그러한 물고기가 여러마리라면, 가장 왼쪽에 있는 물고기를 먹는다.**
- 가장 처음에 아기 상어의 크기는 2이다.
- 아기 상어는 자신의 크기와 같은 수의 물고기를 먹을 때 마다 크기가 1 증가한다. 



- 0: 빈 칸
- 1, 2, 3, 4, 5, 6: 칸에 있는 물고기의 크기
- 9: 아기 상어의 위치

---

## Idea

- BFS 를 활용하여 거리를 저장하고 물고기의 위치를 탐색한다.
- 물고기를 만나면 물고기 위치를 저장하고 같은 거리에 있는 위치를 모두 탐색하고 탐색을 종료한다.
-  저장된 물고기가 두 마리 이상이면 가장 위, 가장 왼쪽에 있는 물고기를 선택한다.
- 새로운 위치에서 재 탐색을 진행한다.

---

## Problem

1.  새로운 물고기를 만났을 때 바로 멈추면 안되고 같은 거리에 있는 위치를 모두 탐색한 뒤 탐색을 멈춰야함
2.  새로운 물고기를 먹었을 때 그 위치에서 네방향 탐색을 다시 실행해야함
3.  같은 거리에 두 개이상의 물고기가 존재한다면 가장 위, 가장 왼쪽에 있는 물고기를 선택해야함

---

## Revision

1. 같은 거리에 존재하는 위치의 크기를 파악하여 for문으로 경계를 나눠준다. 
2. while 문을 활용하여 새로운 물고기를 만났을 때 bfs함수가 끝나면 다시 시작 점을 설정하여 탐색한다.
3. sort() 함수는 0번째 인덱스를 기준으로 정렬하고 같다면 1번째 인덱스를 기준으로 정렬해준다.


---

## Code (BFS)

```python
from collections import deque

def bfs(i, j):
    global cnt, size, eat
    global fish

    feed = []
    visited = [[0] * n for _ in range(n)]
    visited[i][j] = cnt

    deq = deque()
    deq.append((i, j))

    while deq and not feed:

        for _ in range(len(deq)):                   # 거리가 같은 위치를 다 탐색하고 먹이가 있는지 판단하기위해
            i, j = deq.popleft()

            for k in range(4):
                ni = i + di[k]
                nj = j + dj[k]
                if 0 <= ni < n and 0 <= nj < n and space[ni][nj] <= size and not visited[ni][nj]:
                    deq.append((ni, nj))                    # 갈 수 있는 길 저장
                    visited[ni][nj] = visited[i][j] + 1     # 거리 저장

                    if 0 < space[ni][nj] < size:    # 먹이가 있으면
                        cnt = visited[ni][nj]       # 새로운 탐색을 위해 이 위치까지의 거리 저장
                        feed.append((ni, nj))       # 먹을 수 있는 물고기가 있으면 새로운 탐색을 위해 저장

    return feed                                     # 같은 거리에 있는 먹이 위치를 return

n = int(input())
space = [list(map(int, input().split())) for _ in range(n)]

di = [-1, 1, 0, 0]      # 상 하 좌 우
dj = [0, 0, -1, 1]

fish = [0] * 7          # 각 사이즈의 물고기 개수
size = 2
cnt = eat = 0

for i in range(n):
    for j in range(n):
        if space[i][j] and space[i][j] != 9:
            fish[space[i][j]] += 1
        if space[i][j] == 9:
            x, y = i, j
            space[i][j] = 0

# 처음 탐색
restart = bfs(x, y)

# 재 탐색
while sum(fish[1:size]) > 0 and restart:    # 먹을 수 있는 물고기가 전체 공간에 존재하고 새로운 탐색을 위한 물고기 위치가 존재하면
    restart.sort()                          # 먹을수 있는 물고기가 많으면 가장 위, 가장 왼쪽 선택
    x = restart[0][0]
    y = restart[0][1]

    space[x][y] = 0

    eat += 1
    fish[space[x][y]] -= 1              # 물고기 개수 조절

    if size == eat:                     # 상어 사이즈 조절
        size += 1
        eat = 0

    restart = bfs(x, y)

print(cnt)
```

---

## Comment

- 조건이 많을 때는 조건을 꼼꼼히 읽고 코드를 짜기전에 정리해보는 것이 중요하다.
