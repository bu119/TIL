# 16236. 아기상어

## 아기 상어가 엄마 상어에게 도움을 요청하지 않고 물고기를 잡아먹을 수 있는 시간 구하기

#### [16236. 아기상어](https://www.acmicpc.net/problem/16236)

- 리모컨에는 버튼이 0부터 9까지 숫자, +와 -가 있다.
- 채널 0에서 -를 누른 경우에는 채널이 변하지 않고, 채널은 무한대 만큼 있다.
- 이동하려고 하는 채널은 N이다.
- 수빈이가 지금 보고 있는 채널은 100번이다.

---

## Idea

- 브루트포스 알고리즘
- BFS 또는 DFS를 통한 완전탐색

---

## Problem

1.  그리디한 방법으로 구현하였더니 반례가 계속 발생한다.

---

## Revision

1. 브루트포스 알고리즘임을 인지하고 완전 탐색으로 구현한다.


---

## Code (완전탐색)

```python
channel = int(input())
broken_n = int(input())
if broken_n:
    broken = input().split()
else:
    broken = []

cnt = abs(channel - 100)                				# up_down으로 채널 검색하는 수

for number in range(1000001):           				# 완전탐색으로 버튼 눌러서 찾기

    num = str(number)
    n = len(num)

    for i in range(n):
        if num[i] in broken:           				 	# 버튼을 누를 수 없는 수가 나오면 다른 수 탐색
            break
        if i == n - 1:                  				# 모든 수가 버튼을 누를 수 있으면 
            cnt = min(cnt, abs(number - channel) + n)   # 버튼 누른 수와 +-로 찾은 수 중 최소값 찾기

print(cnt)
```



### Fail Code (그리디)

```python
def find_num(arr):                      # 리스트에서 숫자 찾기
    numb = 0
    a = len(arr)
    for x in range(a):
        numb += arr[x] * (10**(a-1-x))
    return numb


def close_num(number):                  # 가까운 숫자 찾기
    close = number
    diff = 10
    for y in range(len(button)):        # 이용가능한 버튼
        temp = abs(number - button[y])
        if diff > temp:
            diff = temp
            close = button[y]
    return close


N = input()
broken_n = int(input())
button = list(range(10)) # 리모컨 동작 가능한 번호
if broken_n:
    broken = list(map(int, input().split()))
    for i in broken:
        button.remove(i)

if N == '100':
    print(0)
else:
    channel = list(map(int, N))     # 찾는 채널 번호를 리스트로 변경
    num = []
    c = len(channel)                # 채널 자리수
    rest1 = rest2 = 0
    for j in range(c):
        tmp = close_num(channel[j])
        num.append(tmp)
        if tmp > channel[j]:        # 원래 수보다 큰 수가 가까우면
            rest1 = c - j - 1
            break
        elif tmp < channel[j]:      # 원래 수보다 작은 수가 가까우면
            rest2 = c - j - 1
            break                   # 수 비교를 멈추고

    num2 = []
    if rest1:                       # 앞자리 수가 크면
        for _ in range(rest1):
            num.append(button[0])   # 가장 작은 수
            if rest1 == c-1:        # 첫 자리 부터 변화가 있으면 작은 수 일 때도 비교
                num2.append(button[-1])

    if rest2:                       # 앞자리 수가 작으면
        for _ in range(rest2):
            num.append(button[-1])  # 가장 큰 수

    ans = abs(int(N) - find_num(num)) + c
    if 100 < int(N) < 110:
        ans = min(ans, abs(int(N) - 100))
    if num2:
        ans2 = abs(int(N) - find_num(num2)) + c-1
        ans = min(ans, ans2)

    print(ans)
```

---

## Comment

- **그리디로 구현하지말고 완전탐색하자!**
- **브루투포스 알고리즘 연습하기**
