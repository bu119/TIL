# 1215. 회문1

## 8x8 평면 글자판의 가로, 세로에 제시된 길이를 가진 회문의 총 개수 구하기

- 거꾸로 읽어도 앞에서부터 읽은 것과 같은 문장이나 낱말을 회문이라 한다.



1.  문자를 입력받아 8*8 행렬을 만든다
2.  각 행을 탐색하여 제시된 길이만큼 끊어 뒤집었을때 같은 리스트를 찾아 숫자를 센다.
3.  행과 열을 바꾼다.
4.  같은 방법으로 열이 바뀐 행을 탐색한다.



### Initial Code

```python
# 1
for tc in range(10):
    n = int(input())
    arr = []
    for s in range(8):
        abc = list(input())
        arr.append(abc)
# 2
    cnt = 0
    for i in range(8):  # 행 탐색
        for j in range(8-n+1):
            array = arr[i][j:j+n]     # i행 리스트를 n칸씩 자름
            if array == array[::-1]:
                cnt += 1

# 3
    for row in range(8):     # 행, 열 바꾸기
        for col in range(8):
            if row < col:
                arr[row][col], arr[col][row] = arr[col][row], arr[row][col]
# 4
    for i in range(8):  # 열 탐색
        for j in range(8-n+1):
            array = arr[i][j:j + n]
            if array == array[::-1]:
                cnt += 1

    print(f"#{tc+1} {cnt}")
```



- 2, 4번이 반복 시행되므로 함수로 만든다.

```python
# 각 행의 회문 개수를 구함
def palindrome(arr, n):
    cnt = 0
    for i in range(8):   # 행 탐색
        for j in range(8 - n + 1):
            array = arr[i][j:j + n]   # i행 리스트를 n칸씩 자름
            if array == array[::-1]:
                cnt += 1  # 같으면 숫자를 셈
    return cnt
```



- 3번을 zip 내장 함수를 사용하여 표현할 수 있다.

```python
# 행렬을 바꾸는 내장함수
arr =[[], [], []]     # 2차원 리스트
arr = list(zip(*arr)) # arr의 모든 요소의 행과 열을 바꿈
```



### final Code

```python
def palindrome(arr, n):  # 각 행의 회문 개수를 구하는 함수 생성
    cnt = 0
    for i in range(8):  # 행 탐색
        for j in range(8 - n + 1):
            array = arr[i][j:j + n]   # i행 리스트를 n칸씩 자름
            if array == array[::-1]:
                cnt += 1
    return cnt

for tc in range(10):
    n = int(input())
    arr = []
    for s in range(8):
        abc = list(input())
        arr.append(abc)

    palindrome1 = palindrome(arr, n) # 행 탐색

    # 행과 열 바꾸기 (내장함수 사용)
    arr = list(zip(*arr))

    palindrome2 = palindrome(arr, n) # 열 탐색

    print(f"#{tc+1} {palindrome1 + palindrome2}")
```



### Error (어려움)

```python
if arr[i][j:j+n] == arr[i][j+n-1:j-1:-1]
```

- 리스트의 슬라이싱 부분에서 error 발생 
  - `arr[i][4:-1:-1]` 이면 리스트의 인덱스 4에서 0 까지 [4, 3, 2, 1] 을 반환한다고 생각.
  - 하지만 [] 빈 리스트를 반환함



```python
arr = [1,2,3,4,5,6,7,8,9,10]

arr[4:0:-1] = [4,3,2]  # 인덱스 4 ~ 1까지 역순으로 출력

arr[4: :-1] = [4,3,2,1] # 인덱스 4 ~ 0까지 역순으로 출력

arr[4:-1:-1] = [] # [] 빈리스트 출력
```



### Error 수정

- 복잡해진다.

```python
for i in range(8):  # 열 탐색
    for j in range(8-n+1):
        if j == 0:
            if arr[i][:n] == arr[i][n-1::-1]:
                cnt += 1
        else:
            if arr[i][j:j+n] == arr[i][j+n-1:j-1:-1]:  # ex) 0에서 3 까지 == 3에서 0 까지
                cnt += 1
```



### 중요!

-  행과 열을 바꾸는 zip 내장 함수를 사용하여 표현
-  슬라이싱
   - `[4: :-1]` : 인덱스 4 ~ 0까지 역순
   - `[4:-1:-1]` : [] 빈리스트

