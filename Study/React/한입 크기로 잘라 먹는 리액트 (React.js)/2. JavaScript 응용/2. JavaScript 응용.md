# JavaScript 응용

## 1. **Truthy & Falsy**

자바스크립트의 조건식에는 boolean형을 넣지 않아도 JS 만의 기준으로 값을 참 또는 거짓으로 인식하여 분류하는 기능이 있다.

### Truthy (참 같은 값)

true가 아니여도 참으로 인식하는 값

- `string`, `number`, `[]` (빈 배열), `{}` (객체 리터럴), `숫자`, `문자열` ( 문자열 “0”, 문자열 “false” ), `Infinity`

### Falsy (거짓 같은 값)

false가 아니여도 거짓으로 인식하는 값

- `null`, `undefined`, `숫자 0`, `-0`, `NaN`, `“ ”` (빈 문자열)

```jsx
// Truthy - 빈 배열 []

let a = [];
if (a) {
  console.log("TRUE");           // TRUE
} else {
  console.log("FALSE");
}
// Falsy - 빈 문자열 ""

let a = "";
if (a) {
  console.log("TRUE");
} else {
  console.log("FALSE");        // FALSE
}
```

- 값이 undefined, null 일 때 예외 처리

```jsx
const getName = (person) => {
  if (person === undefined || person === null) {
    return "객체가 아닙니다.";      // 예외 처리
  }
  return person.name;
};

let person;
const name = getName(person);
console.log(name);                // 객체가 아닙니다.
```

- if문이 아닌 Falsy 속성으로 쉽게 예외 처리

```jsx
// !person 으로 값이 undefined, null 인 것을 한방에 해결

const getName = (person) => {
  if (!person) {                     // false NOT => true
    return "객체가 아닙니다.";        // 예외 처리
  }
  return person.name;
};

let person;
const name = getName(person);
console.log(name);                // 객체가 아닙니다.
```

## 2. 삼항연산자

if문을 한줄로 나타난 것으로 `조건식 ? 참인 경우 : 거짓인 경우 ;`처럼 작성한다.

```jsx
let a = 3;

// if 문으로 나타내면
if (a >= 0) {
  console.log("양수");
} else {
  console.log("음수");
}

// 삼항연산자로 나타내면
a >= 0 ? console.log("양수") : console.log("음수");
let a = [];

a.length === 0 ? console.log("빈 배열") : console.log("안 빈 배열");
```

- 값을 반환 할 때 (return)

```jsx
let a = [1, 7];

// 대입연산자를 활용하여 삼항연산자의 결과 값을 상수에 저장한다.
const arrayStatus = a.length === 0 ? "빈 배열" : "안 빈 배열";
console.log(arrayStatus);
```

- Truthy & Falsy 개념 이용

```jsx
let a;

const result = a ? true : false;
console.log(result);              // false
```

- 중첩 삼항 연산자

아래처럼 삼항연산자를 이중으로 중첩해서 사용할수도 있다. 하지만, 이런 경우는 if문으로 작성하는 것이 가독성이 더 좋기 때문에 ****if문을 사용하는 것을 권장한다.

즉, **중첩 삼항연산자는 코드의 가독성을 해치는 경향이 있으므로 중첩 if문 사용을 권장**

```jsx
// 학점 계산기
// 중첩 삼항 연산자

let score = 100;
score >= 90
  ? console.log("A+")               // A+
  : score >= 50
  ? console.log("B+")
  : console.log("f");
// 중첩 if문 (가독성이 더 좋다.)

let score = 80;
if (score >= 90) {
  console.log("A+");
} else if (score >= 50) {
  console.log("B+");               // B+
} else {
  console.log("f");
}
```

------

## **3. 단락회로 평가**

논리 연산자의 특성을 이용한 문법이다. 왼쪽에서 오른쪽으로 연산하게 되는 논리 연산자의 순서를 이용한다.

즉, **피연산자 중, 뒤에 위치한 피연산자를 확인할 필요 없이 연산을 끝내버리는 것**을 **단락회로 평가**라 한다.

### `&&` (and)

**앞의 조건이 false면** 뒤의 조건은 볼 필요없이 **결과 값은 false**이다.

### `||` (or)

**앞의 조건이 true**면 뒤의 조건은 볼 필요없이 **결과 값은 true**이다.

```jsx
console.log(false && true) // false
console.log(true || false) // true
```

- 단락회로 평가를 활용한 쉬운 예외 처리

```jsx
const getName = (person) => {
  const name = person && person.name;       // true && true이므로 name이 true이다.
  return name || "객체가 아닙니다.";          // name이 true면 or 연산에서는 뒤의 조건을 볼 필요 없으므로 앞에 있는 name값이 반환된다.
};

let person = { name: "bu" };
const name = getName(person);
console.log(name);                          // bu
const getName = (person) => {
  const name = person && person.name;       // person이 false 이므로 뒤의 조건을 볼 필요없이 name은 false이다.
  return name || "객체가 아닙니다.";          // name이 false 이면 or 연산에서는 뒤에 값을 확인해야한다. 뒤의 조건이 문자열로 true이므로 문자열 값이 반환된다.
};

let person = null;
const name = getName(person);
console.log(name);                          // 객체가 아닙니다.
```

------

## **4. 조건문 업그레이드**

- 주어진 문자열이 한식 종류에 포함되는 지 확인하기

```jsx
function isKoreanFood(food) {
  // if (food === "불고기" || food === "비빔밥" || food === "떡볶이") {
  if (["불고기", "떡볶이", "비빔밥"].includes(food)) {
    return true;
  }
  return false;
}

const food1 = isKoreanFood("불고기");
const food2 = isKoreanFood("파스타");
console.log(food1);                      // true
console.log(food2);                      // false
```

- 객체의 괄호 표기법으로 복잡한 조건문을 효율적으로 해결 가능

```jsx
const meal = {
  한식: "불고기",
  중식: "멘보샤",
  일식: "초밥",
  양식: "스테이크",
  인도식: "카레"
};

const getMeal = (mealType) => {
  return meal[mealType] || "굶기";
};

console.log(getMeal("중식"));          // 멘보샤
console.log(getMeal());                // 굶기
```

## 5. 비 구조화 할당(구조 분해 할당)

객체의 경우 인덱스를 기준으로 구조분해할당이 이루어지지만, 객체의 경우 키값을 기준으로 구조분해할당이 이루어집니다. 그래서 각 element의 순서는 중요하지 않으며, key와 동일하게 변수의 이름을 적어주어야 합니다. 하지만 다른 변수의 이름에 저장하고 싶다면 `key이름 : 변수이름`과 같이 선언하여 원하는 변수이름에 할당할 수 있습니다. 배열과 객체 모두 `변수이름 = 값`의 형태로 default값을 설정할 수 있습니다.

- **배열**

```jsx
let arr = ["one", "two", "three"];

// 일반적인 방법
let one = arr[0];
let two = arr[1];
let three = arr[2];

console.log(one, two, three);
```

- 구조 분해 할당 - `[]`를 활용하여 배열의 값을 순서대로 할당받아서 사용하는 방법

```jsx
// 1. 비 구조화 할당
let arr = ["one", "two", "three"];
let [one, two, three] = arr;

// 2. 배열의 선언 분리 비 구조화 할당
let [one, two, three] = ["one", "two", "three"];

console.log(one, two, three);                    // one two three
```

- 배열의 요소 보다 변수가 많을 때 (기본 값 설정)

```jsx
let [one, two, three, four = ""] = ["one", "two", "three"];

console.log(one, two, three, four);            // one two three ""
```

- swap - 배열의 구조 분해 할당을 활용하여 변수를 교환할 수 있다.

```jsx
let a = 10;
let b = 20;

[a, b] = [b, a];

console.log(a, b);          // 20 10
```

- **객체**

```jsx
let object = { one: "one", two: "two", three: "three" };

// 기존에는 이렇게 하나하나 할당하여 사용
let one = object.one;
let two = object.two;
let three = object.three;

console.log(one, two, three);                          // one two three
```

- 객체의 구조분해할당 - object (객체) 의 `key`값을 기준으로 할당

```jsx
let object = { one: "one", two: "two", three: "three" };

let { one, two, three } = object;

console.log(one, two, three);                        // one two three
// 순서가 아니라 Key 값을 기준으로 할당
let object = { one: "one", two: "two", three: "three", name: "bu" };

// 할당
let { name, one, two, three } = object;

console.log(one, two, three, name);                 // one two three bu
```

- 존재하지 않는 프로퍼티 값을 할당 받고자 한다면 **기본 값을 할당**할 수 있다.

```jsx
let { one, name: myName, two, three, abc = "four" } = object;

console.log(myName, one, two, three, abc);         // bu one two three four
```

- Key 값을 활용하여 비구조화 할당을 하지만 변수명을 다르게 하고 싶다면 ?

```jsx
let object = { one: "one", two: "two", three: "three", name: "bu" };

// key 값 : 변수 명
let { name: myName, one: oneOne, two, three} = object;
// name이라는 key값을 기준으로 myName이라는 변수에 할당하겠다

console.log(oneOne, two, three, myName);             // one two three bu
```

------

## 6. spread 연산자

spread연산자는 `...`으로 나타내며, 해당 위치에 해당 객체를 펼친다는 뜻입니다.

( `...` 바로 뒤에 오는 객체를 펼쳐준다는 뜻 )

```jsx
const cookie = {
  base: "cookie",
  madeIn: "korea"
};

const chocochipCookie = {
  // base: "cookie"
  // madeIn: "korea"
  ...cookie,
  toping: "chocochip"
};

const strawberryCookie = {
  // base: "cookie"
  // madeIn: "korea"
  ...cookie,
  toping: "strawberry"
};

console.log(chocochipCookie);      // {base: "cookie", madeIn: "korea", toping: "chocochip"}
console.log(strawberryCookie);     // {base: "cookie", madeIn: "korea", toping: "strawberry"}
```

- 배열에도 사용 가능 ( 배열의 원소를 펼칠 수 있다. )

```jsx
const noTopingCookies = ["촉촉한 쿠키", "안 촉촉한 쿠키"];
const topingCookies = [
  "바나나 쿠키",
  "블루베리 쿠키",
  "딸기 쿠키",
  "초코칩 쿠키"
];

// 배열의 원소를 차례대로 붙여넣을 수 있다.
const allCookies = [...noTopingCookies, "어떤 쿠키", ...topingCookies];

console.log(allCookies);  // ["촉촉한 쿠키", "안 촉촉한 쿠키", "어떤 쿠키", "바나나 쿠키", "블루베리 쿠키", "딸기 쿠키", "초코칩 쿠키"]
```

------

## 7. 동기 & 비동기

- 자바스크립트의 싱글 스레드는 동기방식으로 작업을 처리합니다. -> 동기적 처리를 할 경우 하나의 작업이 오래 걸릴 시 하나의 작업이 종료되기 전까지 멈추기 때문에 전반적인 흐름이 느려집니다. -> 여러 개의 작업을 동시에 실행시킵니다. 작업이 끝난 것은 콜백함수를 통해서 확인합니다. (비동기작업)
- 싱글스레드로 비동기를 실행시키는 방법
  - 오랜 시간이 걸리는 작업의 경우 Web APIs로 이동하여 지정된 시간동안 기다리게 됩니다. 그리고 주어진 시간이 모두 지나면 Callback queue로 들어가게 되고, 해당 함수는 Callback queue에서 기다리다가 Call Stack이 비게 되면 Event Loop에 의해서 Call Stack으로 옮겨지게 됩니다.

### 자바스크립트의 싱글 스레드 작업 수행 방식

우리가 처리해야 할 일이 taskA, taskB, taskC가 있다고 할 때,

### 1. 동기 방식의 처리

코드가 작성된 순서대로 작업을 처리하며 이전 작업이 진행 중 일 때는 다음 작업을 수행하지 않고 기다린다. 앞에 작업이 끝날 때 까지 기다렸다가 바로 뒤에 작업을 실행한다.

- **Thread** : 코드를 한줄 한줄 실행시켜준다.
- **블로킹** **방식** : 싱글 스레드가 작성된 순서대로 실행하며 이전 작업이 진행 중일 때는 다음 작업을 수행하지 않는 것

```jsx
// 동기
function taskA() {
  console.log("A 작업 끝");
}

taskA();
console.log("코드 끝");

// A 작업 끝 
// 코드 끝
```

### 2. **동기처리 방식의 문제점**

하나의 작업 오래 걸리면, 오래 걸리는 하나의 작업 종료 전까지 모든 작업이 올 스탑 되기 때문에, 전반적인 흐름이 느려진다.

- MultiThread (멀티 스레드)
  - 코드를 실행하는 일꾼 Thread를 여러 개 사용하여 각각의 일꾼 Thread에게  작업 분할 가능
  - 하지만, 자바스크립트는 싱글 스레드 방식으로 동작한다.

### 3. 비동기 방식의 처리

싱글 스레드 방식을 이용하면서, 여러 개의 작업을 동시에 실행시킨다.

즉, 먼저 작성된 코드의 결과를 기다리지 않고 다음 코드를 바로 실행한다.

- **논 블로킹** **방식** : 하나의 작업이 쓰레드를 점유하지 않는, 하나의 작업을 수행할 때 쓰레드가 다른 작업을 하지 못하도록 블로킹을 하지 않는 방식

```jsx
function taskA() {
  // 타이머를 만들수 있는 내장 비동기 함수 (파라미터: 콜백함수, 딜레이 타임)
  setTimeout(() => {
    console.log("A task end");
  }, 2000);                       // 2000 : 2초
}
taskA();
console.log("코드 끝");

// 코드 끝 
// A task end
```

- 각각의 task에 콜백 함수를 붙여서 작업이 끝났음을 확인한다.

```jsx
// 인자로 a, b를 넘기고 a+b를 3초 뒤에 리턴하고 싶다면
function taskA(a, b, cb) {
  // cb: 콜백 함수
  // 내장 비동기 함수 (파라미터: 콜백함수, 딜레이 타임)
  setTimeout(() => {
    const res = a + b; // 지역 상수 res에 저장
    cb(res);
  }, 3000);
}

taskA(3, 4, (res) => {
  console.log("A TASK RESULT : ", res);
});
console.log("코드 끝");

// 코드 끝 
// A TASK RESULT :  7
```

- 비동기 처리를 수행하는 함수 taskA, B, C에 콜백 함수를 전달하여 결과 값 알아보기

```jsx
// 함수 정의

// 인자로 a, b를 넘기고 a+b를 3초 뒤에 리턴하고 싶다면
function taskA(a, b, cb) {
  // cb: 콜백 함수
  // 내장 비동기 함수 (파라미터: 콜백함수, 딜레이 타임)
  setTimeout(() => {
    const res = a + b;       // 지역 상수 res에 저장
    cb(res);
  }, 3000);                  // 3초 후 실행
}

function taskB(a, cb) {
  setTimeout(() => {
    const res = a * 2;
    cb(res);
  }, 1000);                 // 1초 후 실행
}

function taskC(a, cb) {
  setTimeout(() => {
    const res = a * -1;
    cb(res);
  }, 2000);                 // 2초 후 실행
}

// 함수 실행

taskA(3, 4, (res) => {
  console.log("A TASK RESULT : ", res);
});

taskB(7, (res) => {
  console.log("B TASK RESULT: ", res);
});

taskC(14, (res) => {
  console.log("C TASK RESULT: ", res);
});

console.log("코드 끝");

// 코드 끝 
// B TASK RESULT:  14
// C TASK RESULT:  -14
// A TASK RESULT :  7
```

- 함수 실행 결과 : 코드 끝 > b > c > a

### 자바스크립트 엔진

1. 자바스크립트 엔진은 `Heap` (메모리 할당), `Call Stack` (코드 실행)으로 이루어져 있다.
2. 비동기 함수를 실행하게 되면, 비동기 함수는 `Web APIs`에 옮겨지게 된다. 여기서 지정한 시간이 지나기를 기다리며 바로 다음 코드를 실행한다.
3. 비동기 함수에게 지정한 시간이 지나면  `Web APIs`에 있던 비동기 함수에 딸려 있던 `콜백함수`는 `Callback Queue`로 이동한다.
4. `Call Stack`에 어떤 함수(실행)도 남겨져 있지 않으면 `Event Loop`에 의해 `콜백 함수`를 `Callback Queue`에서 `Call Stack`으로 이동시킨다.
5. `Call Stack`으로 다시 옮겨지면 콜백 함수가 실행된다.

- 콜백 함수의 연결 (콜백 지옥) → 많이 등장

```jsx
// 함수 정의
// 인자로 a, b를 넘기고 a+b를 3초 뒤에 리턴하고 싶다면
function taskA(a, b, cb) {
  // cb: 콜백 함수
  // 내장 비동기 함수 (파라미터: 콜백함수, 딜레이 타임)
  setTimeout(() => {
    const res = a + b; // 지역 상수에 저장
    cb(res);
  }, 3000); // 3초
}

function taskB(a, cb) {
  setTimeout(() => {
    const res = a * 2;
    cb(res);
  }, 1000); // 1초
}

function taskC(a, cb) {
  setTimeout(() => {
    const res = a * -1;
    cb(res);
  }, 2000); // 2초
}

// 함수 실행
taskA(4, 5, (a_res) => {
  console.log("A RESULT : ", a_res);
  taskB(a_res, (b_res) => {
    console.log("B RESULT : ", b_res);
    taskC(b_res, (c_res) => {
      console.log("C RESULT : ", c_res);
    });
  });
});

console.log("코드 끝");

// 코드 끝 
// A RESULT :  9
// B RESULT :  18
// C RESULT :  -18
```

- 콜백지옥에서 구원하기 위한 자바스크립트의 비동기 담당 객체 → Promise

------

## 8. Promise - 콜백 지옥에서 탈출하기

- `콜백지옥` : 연속되는 비동기 함수를 처리할 때 비동기 처리의 결과 값을 사용하기 위해서 콜백이 계속 깊어지는 현상
- `Promise`
  - 콜백지옥을 해결하기 위한 자바스크립트의 비동기를 돕는 객체
  - promise를 사용하면 더 이상 비동기 처리 함수에 콜백을 줄지어 전달할 필요없다.

### 비동기 작업이 가질 수 있는 3가지 상태

- `Pending` (대기 상태) : 비동기 작업이 현재 진행 중, 시작할 수 없는 문제 발생
- `Fulfiled` (**성공**): 비동기 작업이 정상적으로 완료된 상태 - `resolve` (**해결**)
- `Rejected` (**실패**): 비동기 작업이 실패한 상태 - `reject` (**거부**)

콜백함수를 이용하여 비동기 처리의 결과를 성공, 실패로 나타내기

- 성공 → `resolve` (**해결**)

```jsx
// 함수 정의

function isPositive(number, resolve, reject) {
  setTimeout(() => {
    if (typeof number === "number") {
      // 성공 -> resolve
      resolve(number >= 0 ? "양수" : "음수");
    } else {
      // 실패 -> reject
      reject("주어진 값이 숫자형 값이 아닙니다");
    }
  }, 2000);
}

// 함수 실행

isPositive(
  10,
  (res) => {
    console.log("성공적으로 수행됨 : ", res);       // 성공적으로 수행됨 :  양수
  },
  (err) => {
    console.log("실패하였음: ", err);
  }
);
```

- 실패 → `reject` (**거부**)

```jsx
function isPositive(number, resolve, reject) {
  setTimeout(() => {
    if (typeof number === "number") {
      // 성공 -> resolve
      resolve(number >= 0 ? "양수" : "음수");
    } else {
      // 실패 -> reject
      reject("주어진 값이 숫자형 값이 아닙니다");
    }
  }, 2000);
}

isPositive(
  [],
  (res) => {
    console.log("성공적으로 수행됨 : ", res);
  },
  (err) => {
    console.log("실패하였음: ", err);              // 실패하였음:  주어진 값이 숫자형 값이 아닙니다
  }
);
```

`promise` 사용하여 비동기 처리의 결과를 성공, 실패로 나타내기

- 성공 → `then`
  - 작업이 성공하면 then을 시행한다.
  - `resolve` 를 수행했을 때 전달한 결과 값을 받는다.

```jsx
function isPositiveP(number) {
  const executor = (resolve, reject) => {
    // 실행자, 비동기 작업 실질적 수행
    setTimeout(() => {
      if (typeof number === "number") {
        // 성공 -> resolve
        console.log(number);                        // 101
        resolve(number >= 0 ? "양수" : "음수");
      } else {
        // 실패 -> reject
        reject("주어진 값이 숫자형 값이 아닙니다");
      }
    }, 2000);
  };

  // Promise 객체를 생성하면서 executor를 넘겨줌 -> 자동으로 실행됨
  const asyncTask = new Promise(executor);
  return asyncTask;
}

const res = isPositiveP(101);

res
  .then((res) => {
    console.log("작업 성공: ", res);               // 작업 성공:  양수
  })
  .catch((err) => {
    console.log("작업 실패: ", err);
  });
```

- 실패 → `catch`
  - 작업이 실패하면 catch를 시행한다.
  - `reject` 를 수행했을 때 전달한 결과 값을 받는다.

```jsx
function isPositiveP(number) {
  const executor = (resolve, reject) => {
    // 실행자, 비동기 작업 실질적 수행
    setTimeout(() => {
      if (typeof number === "number") {
        // 성공 -> resolve
        console.log(number);
        resolve(number >= 0 ? "양수" : "음수");
      } else {
        // 실패 -> reject
        reject("주어진 값이 숫자형 값이 아닙니다");
      }
    }, 2000);
  };

  // Promise 객체를 생성하면서 executor를 넘겨줌 -> 자동으로 실행됨
  const asyncTask = new Promise(executor);
  return asyncTask;
}

const res = isPositiveP([]);

res
  .then((res) => {
    console.log("작업 성공: ", res);
  })
  .catch((err) => {
    console.log("작업 실패: ", err);          // **작업 실패:  주어진 값이 숫자형 값이 아닙니다**
  });
```

promise 로 콜백지옥 탈출하기

```jsx
function taskA(a, b) {
  return new Promise((resolve, reject) => {
    // executor
    setTimeout(() => {
      const res = a + b;
      resolve(res);
    }, 3000);
  });
}

function taskB(a) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const res = a * 2;
      resolve(res);
    }, 1000);
  });
}

function taskC(a) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const res = a * -1;
      resolve(res);
    }, 2000);
  });
}

// Promise 객체를 사용하여 then, catch로 활용
taskA(5, 1)
  .then((a_res) => {
    console.log("A RESULT: " + a_res);
    return taskB(a_res);
  })
  .then((b_res) => {
    console.log("B RESULT: ", b_res);
    return taskC(b_res);
  })
  .then((c_res) => {
    console.log("C RESULT: ", c_res);
  });

// A RESULT: 6 
// B RESULT:  12
// C RESULT:  -12

// Promise를 이용해서 리턴하고 호출하고 리턴하고 호출하고...
// then을 계속 이어서 부르는 것: then 체이닝
```

------

## ** 참고

## ** JavaScript의 비동기 처리

- JavaScript는 한 번에 하나의 일만 수행할 수 있는 Single Thread 언어로 동시에 여러 작업을 처리할 수 없다.
- 따라서, 비동기 처리를 할 수 있도록 도와주는 브라우저 or Node 환경이 필요하다.
- 이 중에서 브라우저 환경에서의 비동기 동작은 크게 아래의 요소들로 구성된다.
  - JavaScript Engine의 Call Stack : 요청이 들어올 때마다 순차적으로 처리하는 stack(LIFO)기본적인 JavaScript의 single thread 작업을 처리한다.
  - Web API : JavaScript 엔진이 아닌 브라우저에서 제공하는 runtime 환경으로 시간이 오래 소요되는 작업을 처리한다.
  - Task Queue : 비동기 처리된 Callback 함수가 대기하는 Queue(FIFO)
  - Event Loop : Call Stack과 Task Queue를 지속적으로 모니터링 하다 Call Stack이 비어 있다면 Task Queue에서 대기 중인 오래된 작업을 Call Stack으로 Push한다.

### **비동기 처리 동작 방식**

1. 모든 작업은 Call Stack(LIFO)으로 들어간 후 처리된다.
2. 오래 걸리는 작업이 Cal Stack으로 들어오면 Web API로 보내서 처리하도록 한다.
3. Web API에서 처리가 끝난 작업들은 Task Queue(FIFO)에 순서대로 들어간다.
4. Event Loop가 Call Stack이 비어 있는 것을 체크하고, Task Queue에서 가장 오래된 작업을 Call Stack으로 보낸다.

지연시간 0 != 0초 뒤에 출력된다

## ** Callback과 Promise

### 비동기 처리의 단점

비동기 처리의 핵심은 Web API로 들어오는 순서가 아니라 작업이 완료되는 순서에 따라 처리한다.이는 코드의 실행순서가 불명확해 실행결과를 예상하면서 코드를 작성할 수 없게 한다.콜백함수를 사용해 이를 해결한다.

### 콜백 함수

다른 함수의 인자로 전달되는 함수를 콜백 함수라고 한다.시간이 걸리는 비동기 작업이 완료된 후 실행할 작업을 명시하는데 사용되는 콜백함수를 비동기 콜백(asynchronous call back)이라 부른다.

**콜백 함수를 사용하는 이유**비동기 처리를 순차적으로 동작할 수 있게 한다.

**그러나...**

- 콜백 함수는 보통 어떤 기능의 실행 결과를 받아서 다른 기능을 수행하기 위해 많이 사용한다.
- 이 과정에서 비슷한 패턴이 계속 발생해 코드의 가독성을 해치고 유지보수가 어려워지는 비동기 코드가 작성된다.
- 이를 **Callback Hell**이라고 한다.

**Promise**

- Callback Hell 문제를 해결하기 위해 등장한 비동기 처리를 위한 객체
- 비동기 작업의 완료 또는 실패를 나타내는 객체이다.

| Promise          | 설명                                     | 특징                                                  |
| ---------------- | ---------------------------------------- | ----------------------------------------------------- |
| then (callback)  | 요청한 작업이 성공하면 callback 실행     | callback은 이전 작업의 성공 결과를 인자로 전달받는다. |
| catch (callbacK) | then()이 하나라도 실패하면 callback 실행 | callback은 이전 작업의 실패 객체를 인자로 전달받는다. |

------

## **9. async & await - 직관적인 비 동기 처리 코드 작성하기**

### async

async라는 키워드를 function앞에 붙이면 자동으로 return 값을 promise객체의 resolve로 반환해준다.

async를 function앞에 붙이면 함수는 자동적으로 promise를 리턴하는 비동기 처리 함수가 된다.

```jsx
function hello() {
  return "hello"
}

async function helloAsync() {
  return "hello Async"
}

helloAsync().then((res) => {
  console.log(res)                   // hello Async
})
```

### await

await키워드는 async라는 키워드가 붙은 함수내에서만 사용할 수 있고, 해당 키워드를 사용하면 해당 줄은 동기적으로 작동합니다. 즉, 해당 줄이 모두 실행될 때까지 기다렸다가 다음 줄을 실행하게 됩니다.

```jsx
async function helloAsync() {
  await delay(3000)
  return "hello Async"
}

// await 키워드는 async 함수 내에서만 사용 가능
// await 키워드를 비동기 함수의 호출 앞에 붙이면 동기적 함수처럼 작동한다.
```

------

## **10. API 호출하기**

### API

응용 프로그램 프로그래밍 인터페이스

### API 호출

다른 프로그램에게 어떤 데이터를 받기 위해서 말을 거는 것

- https://jsonplaceholder.typicode.com/
  - 개발자들을 위해 무료로 API호출에 대해 더미 데이터를 응답해주는 서비스
  - **Resources** : 테스트를 위해 오픈 API 제공
- `fetch` : API 호출을 도와주는 내장 함수
  - Promise를 반환한다. (API의 성공 객체 자체를 반환한다.)

```javascript
async function getData() {
  let rawResponse = await fetch("<https://jsonplaceholder.typicode.com/posts>");
  let jsonResponse = await rawResponse.json();
  console.log(jsonResponse);
}

getData();

// (100) [Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, …]
```