# JavaScript 응용

## 삼항연산자

if문을 한줄로 나타난 것으로 `조건?참인경우:거짓인경우;`처럼 작성한다.

```javascript
let a = 3
a >= 0 ? console.log("양수") : console.log("음수")
```

아래처럼 삼항연산자를 이중으로 중첩해서 사용할수도 있다. 하지만, 이런 경우는 if문으로 작성하는 것이 가독성이 더 좋기 때문에 if문을 사용하는 것을 권장한다.

```javascript
let score = 100;
score >= 90?
	?console.log("A+")
    :score >= 50
    ?console.log("B+")
    :console.log("f")
```

------

## 비 구조화 할당(구조분해할당)

객체의 경우 인덱스를 기준으로 구조분해할당이 이루어지지만, 객체의 경우 키값을 기준으로 구조분해할당이 이루어집니다. 그래서 각 element의 순서는 중요하지 않으며, key와 동일하게 변수의 이름을 적어주어야 합니다. 하지만 다른 변수의 이름에 저장하고 싶다면 `key이름:변수이름`과 같이 선언하여 원하는 변수이름에 할당할 수 있습니다. 배열과 객체 모두 `변수이름=값`의 형태로 default값을 설정할 수 있습니다.

```javascript
let arr = ["one", "two", "three"]

// 일반 방법
let one = arr[0]
let two = arr[1]
let three = arr[2]

// 구조분해할당
let [one, two, three] = arr
let [one, two, three, four=''] = ["one", "two", "three"]

// swap
let a = 10
let b = 20
[a, b] = [b, a]

// 객체의 구조분해할당
let object = {one: "one", two: "two", three: "three"}
let {one:oneOne, two, three, abc=""} = object
```

------

## spread 연산자

spread연산자는 `...`으로 나타내며, 해당 위치에 해당 객체를 펼친다는 뜻입니다. (배열도 가능)

```javascript
const cookie = {
	base: "cookie",
    madeIn: "korea"
}

const chocoCookie = {
	...cookie,
    toping: "choco"
}

const strawberryCookie = {
	...cookie,
    toping: "strawberry"
}
```

------

## 동기 & 비동기

자바스크립트의 싱글 스레드는 동기방식으로 작업을 처리합니다. -> 동기적 처리를 할 경우 하나의 작업이 오래 걸릴 시 하나의 작업이 종료되기 전까지 멈추기 때문에 전반적인 흐름이 느려집니다. -> 여러 개의 작업을 동시에 실행시킵니다. 작업이 끝난 것은 콜백함수를 통해서 확인(비동기작업)

싱글스레드로 비동기를 실행시키는 법: 오랜 시간이 걸리는 작업의 경우 Web APIs로 이동하여 지정된 시간동안 기다리게 됩니다. 그리고 주어진 시간이 모두 지나면 Callback queue로 들어가게 되고, 해당 함수는 Callback queue에서 기다리다가 Call Stack이 비게 되면 Event Loop에 의해서 Call Stack으로 옮겨지게 됩니다.

------

## Promise - 콜백 지옥에서 탈출하기

비동기 작업이 가질 수 있는 3가지 상태

1. pending(대기상태)
2. fulfilled(성공)
3. rejected(실패)

```javascript
function taskA(a, b) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const res = a + b;
      resolve(res);
    }, 3000);
  });
}
function taskB(a) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const res = a * 2;
      resolve(res);
    }, 1000);
  });
}
function taskC(a, cb) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const res = a * -1;
      resolve(res);
    }, 2000);
  });
}

taskA(5, 1)
  .then((a_res) => {
    console.log(a_res);
    return taskB(a_res);
  })
  .then((b_res) => {
    console.log(b_res);
    return taskC(b_res);
  })
  .then((c_res) => {
    console.log(c_res);
  });
```

------

## async & await

### async

async라는 키워드를 function앞에 붙이면 자동으로 return 값을 promise객체의 resolve로 반환해줍니다.

```javascript
function hello() {
  return "hello"
}

async function helloAsync() {
  return "hello Async"
}

helloAsync().then((res) => {
  console.log(res)
})
```

### await

await키워드는 async라는 키워드가 붙은 함수내에서만 사용할 수 있고, 해당 키워드를 사용하면 해당 줄은 동기적으로 작동합니다. 즉, 해당 줄이 모두 실행될 때까지 기다렸다가 다음 줄을 실행하게 됩니다.

```javascript
async function helloAsync() {
  await delay(3000)
  return "hello Async"
}
```

------

## API & fetch

API: 응용 프로그램 프로그래밍 인터페이스 API호출: 어떤 데이터를 받기 위해서 다른 프로그램에게 말을 거는 것

```javascript
async function getData(){
  let response = await fetch('<https://jsonplaceholder.typicode.com/posts>')
  let jsonResponse = await response.json()
  console.log(jsonResponse)
}

getData()
```