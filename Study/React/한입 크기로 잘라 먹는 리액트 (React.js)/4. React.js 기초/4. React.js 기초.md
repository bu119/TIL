# **4. React.js 기초**

## 1. Why React.js?

**리액트를 쓰는 이유는?**

- **리액트는 component기반의 UI라이브러리**이기 때문에, **중복되는 코드를** **컴포넌트화** 함으로써 유지보수가 쉬워진다.
- 명령형 프로그래밍 방식이 아닌 **선언형 프로그래밍 방식**을 취하고 있다.
- **Virtual DOM** ( 가상의 돔을 사용한다. )

자세히..

1. **첫번째 이유**
   - 문제 발생
     - 중복되는 코드가 많을 때 웹 사이트 유지보수에서 큰 문제가 발생한다.
     - 중복 코드를 작성, 수정해야 할 때 중복된 코드 페이지가 많다면 할 일이 많아진다.
   - 해결
     - **리액트는 component기반의 UI라이브러리**이기 때문에, 중복되는 코드를 컴포넌트화 함으로써 유지보수가 쉬워진다. ( 컴포넌트화 방식 )
2. **두번째 이유**
   - 문제 발생
     - 명령형 프로그래밍 방식 ( 절차를 하나하나 나열해야 한다. ) - **jQuery**
     - 거대한 웹서비스를 코딩 할 때 코드가 너무 길어지고 해석하기 어려워진다.
   - 해결
     - 선언형 프로그래밍 방식 ( 목적을 바로 이야기한다. ) - **React**
     - **리액트는** 명령형 프로그래밍 방식이 아닌 **선언형 프로그래밍 방식**을 취하고 있다.
3. **세번째 이유**
   - 문제 발생
     - DOM ( Document Object Model )
     - document가 계속 업데이트 된다면, 브라우저는 계속해서 많은 작업을 실행해야 한다.
     - 잦은 업데이트시 브라우저는 필요이상으로 많은 연산을 수행해야 되고 결국 성능저하의 문제로 이어진다.
   - 해결
     - **Virtual DOM** ( 가상의 돔을 사용하겠다. )
     - 잦은 업데이트시 발생하는 변화를 실시간으로 매번 실제 DOM에 업데이트 시키지 않고 Virtual DOM에 미리 업데이트 시켜놓고 (렌더링 과정 X) 나중에 한꺼번에 업데이트 함으로써 연산을 줄인다.
     - 5번 업데이트 할 꺼를 한 번에 5개를 업데이트한다.

------

## 2. Create React App

`React.js` : Node 기반의 JavaScript UI 라이브러리

**React.js를 사용하기 위해서 필요한 라이브러리**

- `Webpack` : 다수의 자바스크립트 파일을 하나의 파일로 합쳐주는 모듈 번들 라이브러리
- `Babel` : JSX등의 쉽고 직관적인 자바스크립트 문법을 사용할 수 있도록 해주는 라이브러리
- … 이외에 훨씬 더 많은 라이브러리가 존재

모두 설치하기엔 설치할 라이브러리가 너무 많다.

- `Create React App` : React의 Boiler Plate

  - `Boiler Plate` : 서비스를 개발할 수 있는 틀의 역할을 하는 패키지를 의미한다.

  - 미리 필요한 패키지 다 묶어놓은 것
  - 기초 설정 작업까지 모두 되어있다.

### React App 생성하기

```bash
$ npx create-react-app 앱 이름
```

- `npx` : 설치되어 있지 않은 패키지를 딱 한 번만 쓰고 싶을 때 `npm` 대신 사용

  - npm을 편리하게 이용하기위해 존재하는 도구

- 설치 오류 발생 시 참고 자료

  [Create React App 오류 발생시 해결방법](https://jeong-ran-e.tistory.com/entry/Create-React-App-오류-발생시-해결방법)

위 코드로 React app을 만들고 나면 아래처럼 app이 생성된다.

기본적인 구조 자체는 vue와 동일하다.

![https://velog.velcdn.com/images/alswl2487/post/b15405b3-1fec-4947-9f1b-6379ebb8a1c5/image.png](https://velog.velcdn.com/images/alswl2487/post/b15405b3-1fec-4947-9f1b-6379ebb8a1c5/image.png)

### React App 실행하기

```bash
$ npm start
```

- localhost:3000으로 리액트가 열린다

### React App 끝내기

- 터미널에 단축키 `Ctrl + c` 입력

### React App 살펴보기

- 각각의 component파일은 `컴포넌트 이름.js` 의 형식으로 만든다.
- 컴포넌트 코드는 아래와 같은 구조로 구성된다.
  - 컴포넌트 이름과 동일한 함수에서, 다양한 변수들을 선언해서 사용할 수 있고,
  - 해당 컴포넌트의 JSX코드가 return된다.
    - `JSX` : javascript + html = 자바스크립트 표현식 ( = extension = jsx 문법 )
    - 자바스크립트의 변수나 함수를 html 코드에서 쉽게 사용할 수 있다.
  - 제일 아래에 export를 해주어야 다른 곳에서 import해서 사용할 수 있다.
    - `export default` : 리액트가 주로 사용하는 ex 모듈 시스템
    - export default 는 1번만 가능하다.

```jsx
// App.js

import logo from './logo.svg';
import './App.css';

function App() {
  return (
    <div className="App">
      <header className="App-header">
        <img src={logo} className="App-logo" alt="logo" />
        <p>
          Edit <code>src/App.js</code> and save to reload.
        </p>
        <a
          className="App-link"
          href="<https://reactjs.org>"
          target="_blank"
          rel="noopener noreferrer"
        >
          Learn React
        </a>
      </header>
    </div>
  );
}

export default App;
```

- 아래 코드는 index.js인데, 해당 파일이 index.html에 컴포넌트를 삽입하는 역할을 한다.
- 아래 코드는 App컴포넌트를 index.html의 `root`라는 id를 가진 태그 안에 삽입하라는 뜻이다.

```jsx
// index.js

import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: <https://bit.ly/CRA-vitals>
reportWebVitals();
```

------

## 3. JSX

** HTML with JavaScript

JSX는 React의 component를 만드는데 용이한 문법이다.

### **JSX 문법의 몇 가지 규칙**

1. 닫힘 규칙
   - 항상 모든 태그가 닫혀야 한다.
   - 여는 태그가 있다면 반드시 닫는 태그도 존재해야 한다.
   - Image, br 태그 같이 하나의 태그만으로도 동작하는 태그들은 태그를 선언하자마자 닫아주어야 한다. 이런 태그들을 self closing tag ( 셀프 클로징 태그 ) 라고 한다.
     - `<br/>`, `<image />`
2. 최상위 태그 규칙
   - JSX의 표현식은 반드시 하나의 부모를 가져야한다.
     - 즉, JSX로 컴포넌트를 만들어서 return 하려면 반드시 하나의 최상위 태그로 다른 모든 태그들을 묶어야한다.
   - 최상위 태그란 가장 바깥에 있는 태그를 말하는데, 반드시 최상위 태그로 다른 태그들을 감싸주어야 한다.
   - 최상위 태그로 묶고 싶지 않다면 `React.Fragment` 기능을 사용하여 최상위 태그를 대체할 수 있다.
     - `React.Fragment`는 React의 기능이기 때문에 해당 태그를 사용하기 위해서는 `import React from "react"`를 통해서 React를 불러와주어야 한다.
     - `<React.Fragment></React.Fragment>` 태그를 사용하여 최상위 태그 대신 감싸주면 된다.
     - `<React.Fragment></React.Fragment>`가 귀찮다면 `<></>`으로 작성해도 된다.

- MyHeader.js, MyFooter.js 파일 만들어서 App.js에 불러오기

```jsx
// MyHeader.js

const MyHeader = () => {
    return <header>헤더</header>};

export default MyHeader;
// MyFooter.js

const MyFooter = () => {
  return <footer>myFooter</footer>
}

export default MyFooter;
// App.js

import React from 'react';
import './App.css';
import MyHeader from './MyHeader';
import MyFooter from './MyFooter';

function App() {
  let name = 'bu'

  return (
    // <div className="App"> 
    // 아래의 <React.Fragment> 태그는 <></> 이런 식으로 안을 비워줘도 된다.
    <React.Fragment> 
      <MyHeader/>
      <header className="App-header">
        <h2>안녕 리액트 {name}</h2>
      </header>
      <MyFooter/>
    </React.Fragment>
    // </div>
  );
}

export default App;
```

### **JSX 문법으로 작성한 태그와 CSS를 결합하여 스타일링하기**

1. JSX에서는 class가 JS의 예약어이기 때문에 쓰지 못하고, `className` 이라고 한다.

2. `CSS`

   - CSS 파일을 따로 만들어서 import하는 방식으로 사용될 수 있고,
   - 혹은 style객체를 만들어서 inline으로 적용시키는 방법도 있다.

3. `{}`

   - 중괄호를 이용하여 JSX에 JavaScript 값 사용하기

   - 중괄호 안에는 함수도 들어갈 수 있고, 표현식도 들어갈 수 있다.

   - 하지만, 숫자와 문자열만 들어갈 수 있기 때문에 그 이외의 값이 들어가면 rendering이 되지 않는다.

     - 숫자나 문자열 이외에 배열, boolean 값 등은 넣을 수 없다.

   - `조건부 렌더링` : 삼항 연산자를 이용하여 조건에 따라 각각 다른 요소를 렌더링할 수있다.

2번 예시 )

- CSS 파일 사용하기

```jsx
// App.js

import React from 'react';
import './App.css';
import MyHeader from './MyHeader';
import MyFooter from './MyFooter';

function App() {
  let name = 'bu'

  return (
    <div className="App">

      <MyHeader/>
        <h2>안녕 리액트 {name}</h2>
        <b id='bold_text'>React.js</b>
      <MyFooter/>

    </div>
  );
}

export default App;
/* App.css */

.App {
  background-color: black;
}

h2 {
  color: red;
}

#bold_text {
  color: green;
}
```

- inline ( 인라인 ) 스타일링 사용하기

```jsx
// App.js

import React from 'react';
// import './App.css';
import MyHeader from './MyHeader';
import MyFooter from './MyFooter';

function App() {
  let name = 'bu'

  const style = {
    App : {
      backgroundColor: "black",
      // 카멜케이스로 작성하기
    },
    h2: {
      color: "orange"
    },
    bold_text: {
      color: "green"
    }
  }

  return (
    <div style={style.App}> 
      <MyHeader/>
      <h2 style={style.h2}>안녕 리액트 {name}</h2>
      <b style={style.bold_text}>React.js</b>
      <MyFooter/>
    </div>
  );
}

export default App;
```

<img width="410" alt="스크린샷_20221211_063343" src="https://user-images.githubusercontent.com/109335452/206901878-4398a716-984e-42cc-b1fc-1ab78dfc3b97.png">

3번 예시)

- `{}` 을 이용하여 JSX에 JavaScript 값 사용하기

```jsx
// App.js

// ...

const number = 5;

  return (
    <div style={style.App}> 
      <MyHeader/>
      <h2 style={style.h2}>안녕 리액트 {1 + 2}</h2>
      <b style={style.bold_text}>
        {number}는 : {number % 2 === 0 ? "짝수" : "홀수"}
      </b>
      <MyFooter/>
    </div>
  );
```

<img width="495" alt="스크린샷_20221211_062649" src="https://user-images.githubusercontent.com/109335452/206901889-5f87752c-237c-4cbb-8c69-4f637faa177b.png">

------

## 4. State ( 상태 )

### State

- 계속해서 변화하는 특정 상태
- 상태에 따라 각각 다른 동작을 한다.

### React의 State를 만들고 관리하기

1. react에서 state를 사용하기 위해서는 먼저 아래처럼 import를 해줘야 한다.
   - `import React, {useState} from "react"`
2. 그리고 내가 사용할 state를 선언해주어야 하는데, 다음과 같은 형태로 선언한다.
   - `const [count, setCount] = useState(0);`
   - useState에 전달하는 인자 값이 count의 초기값이 되고,
   - count값을 변경할 때는 setCount를 호출하여 바꾸고자 하는 값을 인자로 전달해주면 된다.
   - count, setCount는 다른 state들과 이름이 겹치면 안된다.
3. 컴포넌트는 자신이 가진 state의 값이 바뀌면 함수를 다시 호출하여 rerender 한다.

```jsx
// Counter.js

import React, {useState} from "react"

const Counter = () => {

  // 0 에서 출발
  // 1 씩 증가하고
  // 1 씩 감소하는
  // count 상태

  const [count, setCount] = useState(0);
  // useState : 배열을 반환하고 배열의 비구조화 할당을 통해서 
  //            0번째 인덱스 count, 1번째 인덱스 setCount 라는 상수로 받아온다.
  // count : 상태의 값으로 사용된다.
  // setCount: count 라는 상태를 변화시키는 상태 변화 함수
  // useState 괄호 안에 값 0은 count라는 상태를 만드는데 초기화 값으로 사용된다.

  // count 증가 함수
  const onIncrease = () => {
    setCount(count + 1);
    // setCount 의 인자로 새로운 상태를 전달
    // 원래 상태 값에 +1
  }

  // count 감소 함수
  const onDecrease = () => {
      setCount(count - 1);
  }

  return (
    <div>
      <h2>{count}</h2>
      <button onClick={onIncrease}>+</button>
      <button onClick={onDecrease}>-</button>
    </div>
  )
}

export default Counter
```

- 리액트에서는 `{}` 를 통해서 함수를 사용한다.
  - `onClick = {onIncrease}` : `onClick` 이벤트를 통해 `onIncrease` 함수를 수행하게 한다.
- 화면의 표시가 실시간으로 계속 바뀐다는 것은 `count` 의 상태가 업데이트 될 때마다 `Counter` 라는 함수가 반환을 다시한다라고 생각할 수 있다. (리렌더)
  - 컴포넌트는 자신이 가진 상태가 변화하면 화면을 다시 그려 리렌더를 한다.
  - 즉, 함수가 다시 호출 된다.

------

## 5. Props

** 컴포넌트에 데이터를 전달하는 방법

### props

- 컴포넌트에 데이터를 전달하는 방법
- 부모 컴포넌트에서 자식컴포넌트에게 값에 이름을 붙여 전달하는 방식을 prop이라 한다.

### 부모컴포넌트에서 자식 컴포넌트로 props전달하기

- 부모 컴포넌트에서 자식 컴포넌트에 인자를 전달한다.
- 전달하는 방식
  - 태그 안에 `인자이름 = {값}`의 형태로 전달한다.
  - 예시) `<Counter initialValue={5} a={1}/>`
- 전달할 인자가 많다면
  - 여러 개를 나열하는 방식으로 해도 되지만
  - 객체를 만들고 spread연산자를 활용하여 전달해도 된다.

예시)

1. 한 개의 prop 전달하기

- App.js (부모) 에서 Counter.js (자식) 에게 initialValue={5} 를 prop으로 전달하기

```jsx
// App.js

function App() {

  return (
    <div> 
      <Counter initialValue={5}/>
    </div>
    
// ...
```

2. 여러 개의 prop 전달하기

- 나열하여 전달하기

```jsx
// App.js

<div> 
  <Counter a={1} b={2} c={3} d={4} initialValue={5}/>
</div>
```

- 객체로 만들어 객체를 펼쳐서 전달하는 spread연산자를 이용하여 전달하기

```jsx
// App.js

function App() {

  const counterProps = {
    a: 1,
    b: 2,
    c: 3,
    d: 4,
    initialValue: 5
  }

  return (
    <div> 
      <Counter {...counterProps}/>
    </div>

//...
```

### 자식 컴포넌트에서 props받아서 사용하기

그렇다면 이렇게 전달한 인자들을 자식 컴포넌트에서 어떻게 받아서 사용할 것인가?

- 자식 컴포넌트에서는 함수의 인자로 전달 받아서 사용한다.
- 한개의 prop을 넘기든, 여러개의 props를 넘기든, 항상 객체로 인자들이 전달된다.
- 따라서 `props.initialiValue` 처럼 dot notation을 통해서 값을 사용하면 된다.
- 만약에 props에서 전달받은 값들 중에서 initialValue만 사용할 것이라면 구조분해할당을 통해서  `({initialValue})` 이렇게 해당 값만 가지고 와도 된다.

예시)

- 부모 컴포넌트에서 내려준 props를 매개변수를 통해 전달 받아서 사용한다.
- props는 객체로 들어오며 점 표기법으로 접근한다.

```jsx
// Counter.js

const Counter = (props) => {

	// props로 받아올 때는 찍어보기
    // console.log(props);

  const [count, setCount] = useState(props.initialValue);

  const onIncrease = () => {
    setCount(count + 1)
  }

  const onDecrease = () => {
    setCount(count - 1)
  }

  return (
    <div>
      <h2>{count}</h2>
      <button onClick={onIncrease}>+</button>
      <button onClick={onDecrease}>-</button>
      <OddEvenResult count={count}/>
    </div>
  )
}
```

- 비 구조화 할당을 통해서 prop을 전달 받을 수 도 있다.

```jsx
// Counter.js

const Counter = ({initialValue}) => {

    const [count,setCount] = useState(initialValue);

    // ...
```

### default props설정하기

그런데, 만약 자식 컴포넌트에서 부모 컴포넌트에게 initialValue를 받아서 사용하고 있었는데, 부모 컴포넌트에서 해당 값을 전달해주지 않는다면, 자식 컴포넌트에서는 오류가 발생할 것이다. 이런 경우를 방지하기 위해서 자식 컴포넌트 내에서 default prop을 설정할 수 있다.

아래처럼 자식 컴포넌트 내에서 함수 밖에 export 문구 위에 작성하며, 이렇게 default를 설정해두면 부모 컴포넌트에서 값을 받아올 때 문제가 생기면 해당 값을 사용하게 된다.

```jsx
Counter.defaultProps = {
  initialValue: 0
}
```

예시)

- 전달받지 못한 data의 default값 설정 가능 ( 에러 방지 가능 )

```jsx
// Counter.js

import React,{useState} from 'react'

const Counter = ({initialValue}) => {

 //...

}

Counter.defaultProps = {
    initialValue: 0 
}

export default Counter
```

### props로 동적인 data 전달하기

Counter.js 안에 있는 count의 상태가 현재 홀수인지 짝수인지를 실시간으로 알려주는 기능 추가하기

```jsx
// Counter.js

import React,{useState} from 'react';
import OddEvenResult from './OddEvenResult';

const Counter = ({initialValue}) => {

    // ...

    return (
        <div>
          <h2>{count}</h2>
          <button onClick={onIncrease}>+</button>
          <button onClick={onDecrease}>-</button>
          <OddEvenResult count={count}/>
      </div>
    );
};

Counter.defaultProps = {
    initialValue: 0,
};

export default Counter;
// OddEvenResult.js

const OddEvenResult = ({count}) => {
  // console.log(count);
  return <>{count % 2 === 0 ? "짝수" : "홀수"}</>;
};

export default OddEvenResult;
```

### component를 다른 component의 props로 전달하기

props로는 뭐든 전달할 수 있기 때문에 component 자체도 전달할 수 있다.

- 컴포넌트를 컴포넌트로 감싼다.
- 아래 코드처럼 App 내에서 `<Container></Container>` 태그 안에 작성된 element들은 Container 태그에 인자로 전달되어, 사용할 수 있게 된다.
- Container 컴포넌트 사이에 배치된 요소들은 Container 컴포넌트에 children이라는 prop으로 전달된다.
- children을 값 처럼 활용하여 사용했다.

```jsx
// Container.js

const Container = ({children}) => {
  return <div style={{margin: 20, padding: 20, border: "1px solid gray"}}>
      {children}
  </div>;
};

export default Container;
```

```javascript
// App.js

// ...
import Container from './Container';

function App() {

  const counterProps = {
    a: 1,

    // ...
  }

  return (
    <Container>
      <div> 
        <MyHeader/>
        <Counter {...counterProps}/>
      </div>
    </Container>
  );

}

export default App;
```

### 리액트의 컴포넌트 리렌더

1. 리액트의 컴포넌트는 본인이 관리하고, 본인이 가진 state가 바뀔 때마다 리렌더가 되고
2. 나에게 내려온 props가 바뀔 때마다 리렌더가 되고,
3. 둘다 아니어도 내 부모가 리렌더가 되면 나도 리렌더가 된다.

### 정리) component가 rerender가 되는 경우

- 내가 관리하는 state에 변화가 생긴 경우
- 부모가 내려주는 props에 변화가 생긴 경우
- 부모가 rerender되는 경우