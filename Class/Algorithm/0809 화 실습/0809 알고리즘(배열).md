# 시간복잡도

- n의 크기가 작아져야한다.
- ! 팩토리얼 : 많이 걸림

## 다항식 (p문제)

1. O (1)

2. O (logn 2) : 2진 탐색

3. O (n) : 순차 탐색
4. O (n log n) : 퀵, 병합 정렬
5. O (n^2) : 버블 , 선택 정렬



## 비결정적 다항식 (NP 문제)

6. O (2^n)

7. O (n!) : 많이 걸린다.



# 배열

- 초기화 : `Arr = [0] * 10`
- `[ [0] * 10 ] * 10` : 2차원은 얕은 복사 되므로 for문으로 돌린다.



# 정렬

### 종류 

- 버블 - 파괴 함수
- 카운팅 - 비파괴 함수
- 선택
- 퀵
- 삽입
- 병합



- 기수 정렬

- shell 정렬

- heap 정렬



## 버블 정렬

```python
def bubble_sort(a):
    for i in range(len(a)-1, 0,-1):
        for j in range(0, i):
            if a[j] > a[j+1]:
                a[j], a[j+1] = a[j+1], a[j]

arr = [55, 7, 78, 12, 42]
print(arr)        # [55, 7, 78, 12, 42]
bubble_sort(arr)
print(arr)        # [7, 12, 42, 55, 78]
```



## 카운팅 정렬 (오늘*)

```python
counts[date[i]] += 1  # date[i]의 값 자체가 counts의 인덱스로 작용
```

- 안정 정렬을 위해 누적하여 계산

  - 같은 수라도 다이아몬드인지 하트인지 다를 수 있다.

  - 숫자를 세고

    | DATA   |  0   |  4   |  1   |  3   |  1   |  2   |  4   |  1   |
    | :----- | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
    | COUNTS |  0   |  1   |  4   |  5   |  6   |  -   |  -   |  -   |
    | TEMP   |  0   |  1   |  1   |  1   |  2   |  3   |  4   |  4   |

    

# 완전검색!!!!!!!!!!!!!! (중요)

- 예전 a형 1번 문제 - 순열조합
  - 완전검색으로 풀고 가지치기 해라.

- 완전검색은 재귀로 한다.
- 성능 개선의 주된 방법 - 가지치기
- 자격검정평가: Adv



## 탐욕(Greedy) 알고리즘

- 머릿속에 떠오르는 생각을 검증 없이 바로 구현하면 그리디 접근이 된다.

- 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여 그것이 최적이라는 보장은 없다.



# 금요 프젝

정수 - 리스트 - 작업 - 정수