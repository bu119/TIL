 # 피자 굽기 (D3)

#### [파이썬 SW문제해결 기본 - Queue]

 ## 화덕에 가장 마지막까지 남아있는 피자 번호를 알아내는 프로그램을 작성하기

- 피자는 1번위치에서 넣거나 뺄 수 있다.
- 화덕 내부의 피자받침은 천천히 회전해서 1번에서 잠시 꺼내 치즈를 확인하고 다시 같은 자리에 넣을 수 있다.
- M개의 피자에 처음 뿌려진 치즈의 양이 주어지고, 
- 화덕을 한 바퀴 돌 때 녹지않은 치즈의 양은 반으로 줄어든다.
- 이전 치즈의 양을 C라고 하면 다시 꺼냈을 때 C//2로 줄어든다.
- 치즈가 모두 녹아 0이 되면 화덕에서 꺼내고, 바로 그 자리에 남은 피자를 순서대로 넣는다.



1. 인덱스와 치즈 양을 튜플로 받기

2. 치즈가 남아있을 때  Q에 넣기

3. 치즈가 다 녹았을 때 총 피자수 확인



### 수도코드

```python
 while len(Q) >  1:
        t = Q.pop(0)   # deQ
        arr[t] = arr[t] // 2  # 치즈 반으로 줄이기
        # 치즈가 남아 있으면 -> Q에 넣기
        if arr[t] != 0:
            Q.append(t)
        # 치즈가 다 녹았을 때 -> 총 피자수 확인
        elif idx <= M:
            Q.append(idx)
            idx += 1
         
    return Q[0]
```



### Code

```python
def pizza():
    Q = []
    for i in range(1, N+1): # 화덕에 N개 피자 넣기
        Q.append(i)
     
    idx = N + 1    # 아직 화덕에 넣지 않은 첫번째 피자
    while len(Q) >  1:
        t = Q.pop(0)   # deQ
        arr[t] = arr[t] // 2  # 치즈 반으로 줄이기
        # 치즈가 남아 있으면 -> Q에 넣기
        if arr[t] != 0:
            Q.append(t)
        # 치즈가 다 녹았을 때 -> 총 피자수 확인
        elif idx <= M:
            Q.append(idx)
            idx += 1
         
    return Q[0]
 
 
T = int(input())
for tc in range(1, T+1):
    N, M = map(int, input().split())        # 화덕크기, 피자갯수
    arr = [0] + list(map(int, input().split()))  # 인덱스 1번부터
    print(f'#{tc} {pizza()}')
```



# 노드의 거리 (D3)

#### [파이썬 SW문제해결 기본 - Queue] 

- bfs 사용



### Code

```python
def bfs(v):
    Q = []
    Q.append(v)
    visited[v] = 1

    while Q:
        v = Q.pop(0)
        #### 하고싶은 일:####
        if v == G:
            return visited[v] - 1

        for w in adj_list[v]:
            if not visited[w]:
                Q.append(w)
                visited[w] = visited[v] + 1
    return 0  # 경로가 없는 경우

T = int(input())
for tc in range(1, T+1):
    V, E = map(int,input().split())
    adj_list = [[] for _ in range(V+1)]
    visited = [0] * (V+1)
    for i in range(E):
        s, e = map(int, input().split())
        adj_list[s].append(e)
        adj_list[e].append(s)
    S, G = map(int, input().split())

    print(f'#{tc} {bfs(S)}')
```



# 미로의 거리 (D3)

#### [파이썬 SW문제해결 기본 - Queue] 

## 미로에서 최소 몇 개의 칸을 지나면 출발지에서 도착지에 다다를 수 있는지 구하기

- bfs 사용



### Code

``` python
def find_start(arr):
    #출발점 찾기
    for i in range(N):
        for j in range(N):
            if arr[i][j] == 2:
                return i, j

def bfs(x, y):
    Q = []
    Q.append((x, y))
    visited[x][y] = 1

    while Q:
        x, y = Q.pop(0)

        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            if 0 <= nx < N and 0 <= ny < N :  # 인덱스 체크
                if arr[nx][ny] == 3:
                    return visited[x][y] - 1
                elif arr[nx][ny] == 0 and visited[nx][ny] == 0:
                    Q.append((nx, ny))
                    visited[nx][ny] = visited[x][y] + 1
    return 0


dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]
T = int(input())
for tc in range(1, T+1):
    N = int(input())
    arr = [list(map(int, input())) for _ in range(N)]
    visited = [[0] * N for _ in range(N)]
    x, y = find_start(arr)
    print(f'#{tc} {bfs(x, y)}')
```

