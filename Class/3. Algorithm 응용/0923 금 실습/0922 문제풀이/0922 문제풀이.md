# 최소합 (D3)

[파이썬 SW문제해결 응용_구현 - 02 완전 검색] 

## 맨 왼쪽 위에서 오른쪽 아래까지 이동할 때, 지나는 칸에 써진 숫자 합계의 최소값 구하기

- NxN 칸에 숫자가 적힌 판이 주어지고, 각 칸에서는 오른쪽이나 아래로만 이동할 수 있다.
- 모든 경로에 대해 합을 계산한 다음 최소값을 찾아도 된다.

## 수도코드

![D3_최소합 수도코드2](https://user-images.githubusercontent.com/109335452/191878352-74e33675-81d5-480a-ab59-3eacb89c9754.png)

## Code

- 완전탐색

```python
def dfs(x, y, ssum):
    global ans
    if x == N-1 and y == N-1:
        if ans > ssum:
            ans = ssum
    else:
        if x + 1 < N:
            dfs(x+1, y, ssum+arr[x+1][y])
        if y + 1 < N:
            dfs(x, y+1, ssum+arr[x][y+1])
 
 
T = int(input())
for tc in range(1, T+1):
    N = int(input())
    arr = [list(map(int, input().split())) for _ in range(N)]
    ans = 0xffffff
    dfs(0, 0, arr[0][0])
    print(f'#{tc} {ans}')
```

- 가지치기

```python
def dfs(x, y, ssum):
    global ans
    
    if ans < ssum:					# 가지치기
        return
    
    if x == N-1 and y == N-1:
        if ans > ssum:
            ans = ssum
    else:
        if x + 1 < N:
            dfs(x+1, y, ssum+arr[x+1][y])
        if y + 1 < N:
            dfs(x, y+1, ssum+arr[x][y+1])
 
 
T = int(input())
for tc in range(1, T+1):
    N = int(input())
    arr = [list(map(int, input().split())) for _ in range(N)]
    ans = 0xffffff
    dfs(0, 0, arr[0][0])
    print(f'#{tc} {ans}')
```

---

# 전자카트 (D3)

[파이썬 SW문제해결 응용_구현 - 02 완전 검색]

## 사무실에서 출발해 각 구역을 한 번씩만 방문하고 사무실로 돌아올 때의 최소 배터리 사용량을 구하기

- 골프장 관리를 위해 전기 카트로 사무실에서 출발해 각 관리구역을 돌고 다시 사무실로 돌아와야 한다.
- 각 구역을 이동할 때의 배터리 사용량은 표로 제공
- 두 구역 사이도 갈 때와 올 때의 경사나 통행로가 다를 수 있으므로 배터리 소비량은 다를 수 있다.

## Idea

- 순열

## Code

- 완전 탐색

```python
def perm(n, k, ssum):
    global ans
    
    if n == k:
        # 0 -> 1 -> 2까지만 포함됨
        ssum += arr[t[N-1]][t[N]]
        if ans > ssum:
            ans = ssum
    else:
        for i in range(n):
            if visited[i]: continue
            visited[i] = 1
            t[k] = i
            perm(n, k+1, ssum + arr[t[k-1]][t[k]])
            visited[i] = 0
 
T = int(input())
for tc in range(1, T+1):
    N = int(input())
    arr = [list(map(int, input().split())) for _ in range(N)]
 
    t = [0] * N + [0]   # 0 1 2 0 으로 저장(출발과 도착을 고정)
    visited = [0] * N
    visited[0] = 1      # 0번은 제외
    ans = 987654321
    perm(N, 1, 0)          # k = 0 인덱스는 제외
    print(f'#{tc} {ans}')
```

- 가지치기

```python
def perm(n, k, ssum):
    global ans
    
    if ans < ssum: 				# 가지치기
        return
     
    if n == k:
        # 0 -> 1 -> 2까지만 포함됨
        ssum += arr[t[N-1]][t[N]]
        if ans > ssum:
            ans = ssum
    else:
        for i in range(n):
            if visited[i]: continue
            visited[i] = 1
            t[k] = i
            perm(n, k+1, ssum + arr[t[k-1]][t[k]])
            visited[i] = 0
 
T = int(input())
for tc in range(1, T+1):
    N = int(input())
    arr = [list(map(int, input().split())) for _ in range(N)]
 
    t = [0] * N + [0]   # 0 1 2 0 으로 저장(출발과 도착을 고정)
    visited = [0] * N
    visited[0] = 1      # 0번은 제외
    ans = 987654321
    perm(N, 1, 0)          # k = 0 인덱스는 제외
    print(f'#{tc} {ans}')
```

---

# 화물도크 (D3)

 [파이썬 SW문제해결 응용_구현 - 03 탐욕 알고리즘]

## 최대 몇 대의 화물차가 화물을 싣고 내릴 수 있는 지 구하기

- 작업 시작 시간과 완료 시간이 매시 정각을 기준으로 표시되어 있고,
- 앞 작업의 종료와 동시에 다음 작업을 시작할 수 있다.

## Idea

- 그리디
- 종료시간을 기준으로 정렬

## 수도코드

![D3_화물도크 수도코드](https://user-images.githubusercontent.com/109335452/191889151-0bd00d43-24cd-4ad5-b058-4c1460921a64.png)

## Code

```python
T = int(input())
for tc in range(1, T+1):
    N = int(input())
    jobs = [list(map(int, input().split())) for _ in range(N)]
    # 종료시간 순으로 정렬
    jobs.sort(key=lambda x:(x[1], x[0]))
    ans = 0
    finish = 0
    for i in range(N):
        if finish <= jobs[i][0]:
            ans += 1
            finish = jobs[i][1]
    print(f'#{tc} {ans}')
```

---

# 컨테이너 운반 (D3)

[파이썬 SW문제해결 응용_구현 - 03 탐욕 알고리즘] 

## 화물의 총 중량이 최대가 되도록 옮겼다면, 옮겨진 화물의 전체 무게가 얼마인지 구하기

- 화물이 실려 있는 N개의 컨테이너를 M대의 트럭으로 A도시에서 B도시로 운반한다.
- 트럭당 한 개의 컨테이너를 운반 할 수 있고, 트럭의 적재용량을 초과하는 컨테이너는 운반할 수 없다.
- A도시에서 B도시로 최대 M대의 트럭이 편도로 한번 만 운행한다.
- 화물을 싣지 못한 트럭이 있을 수도 있고, 남는 화물이 있을 수도 있다.
- 컨테이너를 한 개도 옮길 수 없는 경우 0을 출력한다.

## Code

```python
T = int(input())
for tc in range(1, T+1):
    N, M = map(int, input().split())        # 컨테이너, 트럭
    W = list(map(int, input().split()))     # 화물
    T = list(map(int, input().split()))     # 트럭
 
    W.sort(reverse=True)
    T.sort(reverse=True)
 
    i = j = ans = 0
    while i < N and j < M:
        if W[i] <= T[j]:
            ans += W[i]
            i, j = i+1, j+1
        else:
            i += 1
    print(f'#{tc} {ans}')
```

---

# 베이비진 게임 (D3)

[파이썬 SW문제해결 응용_구현 - 03 탐욕 알고리즘] 

## 두 사람이 가져가게 되는 순서대로 12장의 카드에 대한 정보가 주어졌을 때 승자를 알아내기

- 0부터 9까지인 숫자 카드 4세트를 섞은 후 6개의 카드를 골랐을 때, 연속인 숫자가 3개 이상이면 run, 같은 숫자가 3개 이상이면 triplet이라고 한다.
- 게임을 시작하면 플레이어1과 플레이어 2가 교대로 한 장 씩 카드를 가져가며, 6장을 채우기 전이라도 먼저 run이나 triplet이 되는 사람이 승자가 된다.
- 만약 무승부인 경우 0을 출력한다.

## 수도코드

![D3_베비진 수도코드](https://user-images.githubusercontent.com/109335452/191891065-5f215abf-cb5d-4973-8a82-fae1c56a5051.png)

## Code

```python
def baby_test(c):
    # triplet
    for i in range(10):
        if c[i] >= 3:
            return True
    for i in range(8):
        if c[i] >= 1 and c[i+1] >= 1 and c[i+2] >= 1:
            return True
 
def game():
    c1 = [0] * 10
    c2 = [0] * 10
    for i in range(12):
        n = arr[i]
        if i % 2 == 0:
            c1[n] += 1
        else:
            c2[n] += 1
 
        # 3장 이후부터
        if i > 4:
            if i % 2 == 0:
                if baby_test(c1):
                    return 1
            else:
                if baby_test(c2):
                    return 2
    return 0
 
T = int(input())
for tc in range(1, T+1):
    arr = list(map(int, input().split()))
    print(f'#{tc} {game()}')
```

