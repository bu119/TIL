# D3_세제곱근을 찾아라

## 양의 정수 N에 대해 N = X3가 되는 양의 정수X 를 구하여라.

### Idea

- 이진탐색 이용하기
- 중간 값을 이용해서 작으면 왼쪽에서 탐색, 크면 오른쪽에서 탐색

### Code

```python
def binary_search():
    low = 1
    high = N
    while low <= high:
        mid = (low + high) // 2
        key = mid * mid * mid
        if key == N:
            return mid
        elif key > N:
            high = mid - 1
        else:
            low = mid + 1
    return -1


T = int(input())
for tc in range(1, T + 1):
    N = int(input())
    print(f'#{tc} {binary_search()}')
```



#  D4_정사각형 방

## 처음 어떤 수가 적힌 방에서 있어야 가장 많은 개수의 방을 이동할 수 있는지 구하기

- N^2개의 방이 N×N형태로 늘어서 있다.
- 숫자는 모든 방에 대해 서로 다르다.
- 상하좌우에 있는 다른 방으로 이동할 수 있다.
- 이동하려는 방에 적힌 숫자가 현재 방에 적힌 숫자보다 정확히 1 더 커야 한다.

### Idea

- dfs보다 bfs로 푸는 것이 낫다.
- visited를 사용하는 방버ㅗㅂ

### Code

#### 수도코드

```python
import deque

def bfs(x, y):
    max_v = 0
    deq = deque()
    deq.append((x,y))
    visited[x][y] = 1
    while deq:
        x, y = q.popleft()
        if visited[x][y] > max_v:
            max_v = visited[x][y]
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            if 0 <= nx < n and 0 <= ny < n and arr[nx][nx] == arr[x][y] + 1:
                deq.append((nx, ny))
                visited[ny][nx] = visited[x][y] + 1
    return max_v
 
cnt = 0
for x in range(n):
    for y in range(n):
        ret = bfs(i, j)
        if cnt < ret:
            cnt = ret
            ans = arr[x][y]
        elif ret == cnt and ans > arr[x][y]:
            ans = arr[x][y]
```



