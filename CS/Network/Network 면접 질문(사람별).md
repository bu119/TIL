# Network 면접 질문

## OSI 7 계층

예

- **OSI 7계층의 등장 배경**

  통신이 일어나는 과정을 단계별로 파악하기 위함과 통신 과정 중에 특정한 곳에 이상이 생길 경우에 다른 단계의 장비 및 소프트웨어 등을 건드리지 않고 통신 장애를 일으킨 단계에서 해결하기 위함입니다.

- **네트워크 계층에서 사용되는 통신 단위와 네트워크 계층의 역할**

  통신 단위는 패킷으로 데이터 패킷이 취할 경로를 설정하는 일, 다른 네트워크의 서버가 가동 중인지 확인하는 일, IP 패킷에 주소를 붙이고, 다른 네트워크로부터의 IP 패킷을 수신하는 일 등이 있습니다.

- **MAC 주소와 IP 주소의 차이**

  MAC주소는 데이터링크 계층에서 사용되고, IP 주소는 네트워크 계층에서 사용됩니다. MAC 주소는 하드웨어 기반으로 생성된 물리적 주소(Physical Address)이고, IP 주소는 소프트웨어 기반으로 생성된 논리적 주소(Logical Address)입니다. 때문에 MAC 주소는 변경될 수 없는 반면 IP 주소는 변경될 수 있습니다.

  MAC 주소는 네트워크에 있는 고유한 컴퓨터를 식별하는 데 사용됩니다. 반면 IP 주소는 네트워크에 참여한 컴퓨터와 네트워크의 연결 상태를 식별하는데 사용됩니다.

---

진

- **OSI 7 계층의 각 계층을 간단하게 설명해주세요.**

  OSI (Open Systems Interconnection) 7계층은 네트워크 통신을 설명하기 위해 통신 과정을 7개의 계층으로 나누어 각 계층의 역할과 기능을 보여주기 위해 사용되는 모델입니다.

  1. 물리 계층 (Physical Layer): 데이터 전송을 위한 물리적인 매체와의 상호작용을 처리합니다.
  2. 데이터 링크 계층 (Data Link Layer): 인접한 시스템 간의 신뢰성 있는 데이터 전송을 제공하고 오류 검출 및 수정을 수행합니다.
  3. 네트워크 계층 (Network Layer): 패킷 라우팅과 경로 선택을 담당하며, 목적지까지 데이터를 안전하게 전송합니다.
  4. 전송 계층 (Transport Layer): 송신자와 수신자 간의 데이터 전송을 관리하며, 신뢰성과 흐름 제어를 제공합니다.
  5. 세션 계층 (Session Layer): 통신 세션을 설정, 유지, 종료하며 동기화를 담당합니다.
  6. 표현 계층 (Presentation Layer): 데이터의 형식을 변환하고 암호화, 압축, 해독 등의 기능을 수행하여 상호 운영이 가능하도록 합니다.
  7. 응용 계층 (Application Layer): 사용자와 상호작용하여 네트워크 서비스를 제공하며, 가장 높은 수준의 인터페이스를 제공합니다.



- **캡슐화(Encapsulation) 와 역캡슐화(Decapsulation)에 대해 설명해주세요.**

  캡슐화란 통신 프로토콜의 특성을 포함한 정보를 Header에 포함시켜서 하위 계층에 전송하는 것을 말합니다. 통신 상대측에서 이러한 Header를 역순으로 제거하면서 원래의 Data를 얻는 과정을 역캡슐화라고 합니다.

  

  캡슐화(Encapsulation)는 네트워크 통신에서 데이터를 전송하기 위해 데이터에 헤더와 트레일러를 추가하는 과정입니다. 이 과정에서 상위 계층에서 하위 계층으로 내려갈 때, 데이터에 해당 계층의 헤더 정보가 추가되고, 아래 계층에서 위로 올라올 때 트레일러 정보가 추가됩니다. 이렇게 계층별로 데이터에 헤더와 트레일러가 캡슐화되는 구조로 데이터가 캡슐에 포장되는 것입니다. 각 계층은 자신의 헤더와 트레일러를 사용하여 데이터를 처리하고, 상위 계층으로 데이터를 전달합니다.

  반대로, 역캡슐화(Decapsulation)는 수신 측에서 데이터를 처리하기 위해 헤더와 트레일러를 제거하는 과정입니다. 데이터가 수신되면 각 계층에서 해당하는 헤더와 트레일러를 제거하고, 상위 계층으로 데이터를 전달합니다. 이러한 과정을 통해 데이터가 하위 계층에서 상위 계층으로 전달되며, 최종적으로 응용 계층에서 사용자에게 전달됩니다.

  캡슐화와 역캡슐화는 계층화된 프로토콜 스택에서 데이터를 전송하고 처리하는 과정을 가능하게 하며, 네트워크 통신의 신뢰성과 유연성을 제공합니다.

  

- **TCP/UDP의 차이점을 비교해주세요.**
  1. 연결 지향성 vs 비연결 지향성
     - TCP는 연결 지향적인 프로토콜입니다. 통신 전에 연결을 설정하고, 신뢰성 있는 전송을 보장하기 위해 연결 유지 및 관리를 수행합니다.
     - UDP는 비연결 지향적인 프로토콜입니다. 연결 설정 과정이 없으며, 데이터 그램 단위로 독립적으로 전송됩니다.
  2. 신뢰성
     - TCP는 신뢰성 있는 데이터 전송을 제공합니다. 데이터 손실이나 손상 시 재전송을 수행하며, 순서가 보장되고 중복된 데이터도 제거합니다.
     - UDP는 신뢰성을 보장하지 않습니다. 데이터 손실이나 손상이 발생할 수 있으며, 순서가 보장되지 않고 중복된 데이터도 허용될 수 있습니다.
  3. 통신 방식
     - TCP는 양방향 통신을 지원합니다. 클라이언트-서버 모델에서 연결을 설정하고 양쪽이 상호작용하며 데이터를 주고받습니다.
     - UDP는 단방향 통신을 지원합니다. 주로 일회성 메시지나 스트리밍 데이터 전송에 사용되며, 단방향으로 데이터를 전송하고 응답을 받지 않습니다.
  4. 속도
     - TCP는 신뢰성을 위해 흐름 제어와 오류 복구 메커니즘을 사용하므로, 추가적인 오버헤드가 발생하고 전송 속도가 상대적으로 느릴 수 있습니다.
     - UDP는 신뢰성을 감소시키고 단순한 전송 메커니즘을 사용하므로, 오버헤드가 적고 전송 속도가 빠릅니다.
  5. 사용 사례
     - TCP는 파일 전송, 이메일, 웹 브라우징, 데이터베이스 관리 시스템과 같이 신뢰성이 중요한 애플리케이션에 주로 사용됩니다.
     - UDP는 실시간 스트리밍, 음성 통화, 온라인 게임과 같이 신속한 데이터 전송이 우선인 애플리케이션에 주로 사용됩니다.

---



## TCP 3 way handshake & 4 way handshake

## TCP/IP (흐름제어/혼잡제어)

## UDP

부

- **TCP/IP에서 TCP와 IP의 역할에 대해 설명해주세요**

  TCP 는 신뢰성 있고 무결성을 보장하는 연결을 통해 데이터를 안전하게 전달해주는 전송 프로토콜이고, IP 는 패킷들을 가장 효율적인 방법으로 최종 목적지로 전송하기 위해 필요한 프로토콜이다.



- **TCP와 UDP의 차이점에 대해 설명해주세요**

  TCP는 연결형 서비스로 3-way handshaking 과정을 통해 연결을 설정하기 때문에 높은 신뢰성을 보장하지만, 속도가 비교적 느리다는 단점이 있습니다.

  UDP는 비연결형 서비스로 3-way handshaking을 사용하지 않기 때문에 신뢰성이 떨어지는 단점이 있지만, 데이터 수신 여부를 확인하지 않기 때문에 속도가 빠르다는 장점이 있습니다.

  TCP는 신뢰성이 중요한 파일 교환과 같은 경우에 쓰이고 UDP는 실시간성이 중요한 스트리밍에 자주 사용됩니다.



- **TCP handshake 에서 연결 성립과 연결 해제의 과정에 대해 설명해주세요**

  - 연결 성립은 3 way handshake이고, 다음과 같은 과정을 거친다.
    1. 클라이언트가 서버에게 SYN 패킷을 보낸다 (sequence : x)
    2. 서버가 SYN(x)을 받고, 클라이언트로 받았다는 신호인 ACK와 SYN 패킷을 보낸다 (sequence : y, ACK : x + 1)
    3. 클라이언트는 서버의 응답은 ACK(x+1)와 SYN(y) 패킷을 받고, ACK(y+1)를 서버로 보낸다

  

  - 연결 해제는 4 way handshake이고, 다음과 같은 과정을 거친다
    1. 클라이언트는 서버에게 연결을 종료한다는 FIN 플래그를 보낸다.
    2. 서버는 FIN을 받고, 확인했다는 ACK를 클라이언트에게 보낸다 (이때 서버에서 모든 데이터를 보내기 위해 CLOSE_WAIT 상태가 된다)
    3. 데이터를 모두 보냈다면, 연결이 종료되었다는 FIN 플래그를 클라이언트에게 보낸다
    4. 클라이언트는 FIN을 받고, 확인했다는 ACK를 서버에게 보낸다 (아직 클라이언트가 서버로부터 받지 못한 데이터가 있을 수 있으므로 TIME_WAIT을 통해 기다린다) 서버는 ACK를 받은 이후 소켓을 닫는다. TIME_WAIT 시간이 끝나면 클라이언트도 닫는다.

---

소

- **TCP와 UDP의 특징과 차이**

  주로 TCP는 속도는 느리지만 데이터의 신뢰성과 정확성이 중요한 경우에 사용. 예를 들어, 웹 페이지 로딩, 파일 전송, 이메일 전송 등에서 TCP를 사용함.

  반면 UDP는 단방향 데이터 전송으로 속도가 빨라 실시간성이 중요하거나 데이터 손실이 발생해도 큰 영향을 주지 않는 경우에 사용됨. 예를 들어, 영상 스트리밍, 음성 통화, 온라인 게임 등에서 UDP를 사용

  + 속도의 차이 원인에 대한 질문이 들어온다면?

    TCP에서는 신뢰성을 위해 3 way handsake과정과 같이 연결 설정, 흐름제어 및 혼잡제어, 오류 검사 등과 같은 추가적인 과정을 거침.



- **TCP에서 호스트 간 연결을 설정하는 방법**

  3 way handshake 과정을 거친다. 이 과정은 클라이언트와 서버 사이 신뢰성 있는 연결을 수립하기 위함임

  먼저 클라이언트가 서버에 접속을 요청하는 SYN 패킷을 보낸 후, 서버가 그 SYN패을 받고 클라이언트로부터 받았다는 신호인 ACK와 SYN 패킷을 보냄. 클라이언트는 서버의 응답인 ACK와 SYN패킷을 받고, ACK을 서버로 보냄



- **TCP/IP의 흐름제어/혼잡제어에 대해 설명**

  흐름 제어는 수신측의 버퍼 오버플로우를 방지하기 위해 데이터의 전송 속도를 조절하는 기능, 대표적인 예시로 ‘슬라이딩 윈도우’메커니을 사용함. 송신측은 ACK를 통해 수신측의 버퍼 상태를 확인하여 데이터를 전송하는 양을 조절

  혼잡 제어는 네트워크의 혼잡 상태를 감지하고 네트워크 혼잡을 조절하는 기능으로 대표적인 방식으로 AIMD, Slow Start 방식이 있음

---

진

- **TCP 3way handshake와 4way handshake에 대해 설명해보세요**

  TCP의 3-way handshake와 4-way handshake는 신뢰성 있는 데이터 전송을 위해 사용됩니다. 3-way handshake는 연결 설정에 사용되고, 4-way handshake는 연결 종료에 사용됩니다.

  

  먼저 TCP 3way handshake는 연결 성립을 위해 3가지 단계를 거칩니다.

  1. 클라이언트가 서버에 연결 요청을 보냅니다. 이를 SYN (Synchronize) 패킷이라고 합니다. SYN 패킷에는 클라이언트의 초기 순서 번호 (ISN, Initial Sequence Number)가 포함되어 있습니다.
  2. 서버는 클라이언트의 연결 요청을 받으면 SYN 패킷을 받았다는 응답으로 ACK (Acknowledgment)와 SYN 패킷을 보냅니다.
  3. 클라이언트는 서버의 SYN-ACK 패킷을 받으면 ACK 패킷을 보냅니다.

  

  3-way handshake는 클라이언트와 서버 간의 신뢰성 있는 연결 설정을 보장합니다. 각 단계에서 패킷을 교환함으로써 상대방이 정상적으로 연결 요청을 받고 응답할 수 있는지 확인합니다.

  

  TCP 4 way handshake는 연결 해제를 위해 4가지 단계를 거칩니다.

  1. 클라이언트나 서버 중 한 쪽에서 연결 종료를 요청합니다. 이를 FIN (Finish) 패킷이라고 합니다.
  2. 받은 FIN 패킷에 대한 응답으로 상대방도 연결 종료를 요청합니다. 이를 ACK 패킷으로 응답하고 자신도 FIN 패킷을 보냅니다.
  3. 상대방은 ACK 패킷을 받고 자신의 FIN 패킷을 받아들입니다.
  4. 받은 FIN 패킷에 대해 ACK 패킷을 보내고 연결 종료를 완료합니다.

  

  4-way handshake는 TCP 연결을 안전하게 종료하기 위해 사용됩니다. 각 단계에서 상대방의 응답을 확인하고 연결 종료 과정을 완료합니다.

  

- **TCP와 UDP의 차이점에 대해 설명해보세요**

  TCP (Transmission Control Protocol)와 UDP (User Datagram Protocol)는 둘 다 TCP/IP 프로토콜 스택에서 전송 계층에서 작동하는 프로토콜입니다.

  다음은 TCP와 UDP의 주요 차이점을 비교한 요약입니다

  

  1. 연결 지향성 vs 비연결 지향성

     - TCP는 연결 지향적인 프로토콜입니다. 통신 전에 연결을 설정하고, 신뢰성 있는 전송을 보장하기 위해 연결 유지 및 관리를 수행합니다.
     - UDP는 비연결 지향적인 프로토콜입니다. 연결 설정 과정이 없으며, 데이터 그램 단위로 독립적으로 전송됩니다.

     

  2. 신뢰성

     - TCP는 신뢰성 있는 데이터 전송을 제공합니다. 데이터 손실이나 손상 시 재전송을 수행하며, 순서가 보장되고 중복된 데이터도 제거합니다.
     - UDP는 신뢰성을 보장하지 않습니다. 데이터 손실이나 손상이 발생할 수 있으며, 순서가 보장되지 않고 중복된 데이터도 허용될 수 있습니다.

     

  3. 통신 방식

     - TCP는 양방향 통신을 지원합니다. 클라이언트-서버 모델에서 연결을 설정하고 양쪽이 상호작용하며 데이터를 주고받습니다.
     - UDP는 단방향 통신을 지원합니다. 주로 일회성 메시지나 스트리밍 데이터 전송에 사용되며, 단방향으로 데이터를 전송하고 응답을 받지 않습니다.

     

  4. 속도

     - TCP는 신뢰성을 위해 흐름 제어와 오류 복구 메커니즘을 사용하므로, 추가적인 오버헤드가 발생하고 전송 속도가 상대적으로 느릴 수 있습니다.
     - UDP는 신뢰성을 감소시키고 단순한 전송 메커니즘을 사용하므로, 오버헤드가 적고 전송 속도가 빠릅니다.

     

  5. 사용 사례

     - TCP는 파일 전송, 이메일, 웹 브라우징, 데이터베이스 관리 시스템과 같이 신뢰성이 중요한 애플리케이션에 주로 사용됩니다.
     - UDP는 실시간 스트리밍, 음성 통화, 온라인 게임과 같이 신속한 데이터 전송이 우선인 애플리케이션에 주로 사용됩니다.



- **TCP/IP에서 흐름제어와 혼잡제어는 무엇인지 설명해보세요.**

  - 흐름제어 (endsystem 대 endsystem)

    - 송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위한 기법
    - Flow Control은 receiver가 packet을 지나치게 많이 받지 않도록 조절하는 것
    - 기본 개념은 receiver가 sender에게 현재 자신의 상태를 feedback 한다는 점

    

  - **혼잡제어**

    - 송신측의 데이터 전달과 네트워크의 데이터 처리 속도 차이를 해결하기 위한 기법

---

예

- **TCP의 연결 설정 과정(3단계)과 연결 종료 과정(4단계)이 단계가 차이나는 이유**

  Client가 데이터 전송을 마쳤다고 하더라도 Server는 아직 보낼 데이터가 남아있을 수 있기 때문에 일단 FIN에 대한 ACK만 보내고, 데이터를 모두 전송한 후에 자신도 FIN 메시지를 보내기 때문이다.



- **TCP/IP 혼잡 제어 기법을 사용하는 이유**

  송신 측에서 보내는 데이터의 양이 라우터가 처리할 수 있는 양을 초과하면 초과된 데이터는 라우터가 처리하지 못한다. 송신 측은 초과된 데이터를 손실 데이터로 간주하고 계속 재전송하여 네트워크를 혼잡하게 한다. 이런 상황을 예방하기 위해 송신 측의 전송 속도를 적절히 조절하는 혼잡 제어 기법이 사용된다. 대표적으로 AIMD, Slow Start, 빠른 재전송, 빠른 회복 등이 있다.



- **UDP의 단점**

  데이터의 신뢰성이 없고, TCP와는 다르게 데이터를 쪼개주지 않아 애플리케이션 단에서 직접 패킷을 쪼개 일일이 관리해야 한다.

---



## 대칭키&공개키

## HTTP & HTTPS

## TLS/SSL HandShake

부

- **HTTP를 설명해주세요.**

  HTTP(Hyper Text Transfer Protocol)이란 데이터를 주고 받기 위한 프로토콜이며, 서버/클라이언트 모델을 따릅니다.

  HTTP는 상태 정보를 저장하지 않는 Stateless의 특징과 클라이언트의 요청에 맞는 응답을 보낸 후 연결을 끊는 Connectionless의 특징을 가지고 있습니다.

  

- **HTTP와 HTTPS의 차이점은 무엇인가요?**

  HTTP는 평문 데이터를 전송하는 프로토콜이기 때문에, HTTP로 중요한 정보를 주고 받으면 제 3자에 의해 조회될 수 있습니다.

  이러한 문제를 해결하기 위해 HTTP에 **TLS**(Transport Layer Security) 혹은 **SSL**(Secure Sockets Layer)을 사용하여 암호화가 추가된 프로토콜이 HTTPS입니다.

  HTTP는 원래 TCP와 직접 통신했지만, HTTPS에서 HTTP는 SSL과 통신하고 SSL이 TCP와 통신함으로써 암호화와 증명서, 안전성 보호를 이용할 수 있게 됩니다.

  즉, HTTPS는 HTTP정보를 암호화하며, 공개키 암호화 방식을 거쳐 작동합니다.

  

- **SSL이란 무엇인가?**

  SSL 인증서란 **클라이언트와 서버 간의 통신을 제3자가 보증을 해주는 문서**입니다.

  클라이언트가 서버에 접속한 직후에 서버는 클라이언트에게 이 인증서를 전달합니다.

  그러면 클라이언트는 이 인증서를 보고 신뢰할 수 있는 사람인지 확인을 한 다음에 데이터를 보내는 등의 절차를 수행하게 됩니다.

---

유

- **대칭키 방식과 공개키 방식의 장단점에 대해 설명해보세요**

  대칭키 방식의 장점은 공개키 방식에 비해 속도가 빠르다는 장점이 있습니다. 하지만 키를 교환하는 과정에서 키가 탈취될 위험이 있고, 사용자가 증가할수록 모든 대칭 키를 따로따로 키교환 및 관리해야하기 때문에 관리의 어려움이 발생하는 단점이 있습니다.

  공개키 방식은 공개키가 공개되어있기 때문에 키 배송이 필요없고, 대칭키 방식의 키 배송에서 발생하는 문제를 방지할 수 있다. 따라서 기밀성 보장의 장점이 있다. 하지만 대칭키 암호화 방식에 대해 속도가 느리다는 단점이 있다

  공개키 방식으로 대칭키를 서로 전달하고, 이후 대칭키 방식으로 통신하는 하이브리드 방식을 활용한다면 두 방식의 단점은 극복하고 장점을 극대화 할 수 있다

- **http와 https의 차이에 대해 설명해보세요**

  두 방식 모두 서버와 클라이언트가 자원을 주고 받을 때 사용하는 통신 규약입니다. http는 네트워크 신호가 탈취되면 내용이 노출되는 보안 이슈가 발생할 수 있습니다. 이를 해결하기 위해 SSL 프로토콜을 사용하여 정보를 암호화하는 방식이 https입니다

- **SSL 프로토콜의 작동 방식에 대해 설명해보세요**

  작동 방식을 이해하지 못해서 설명을 못하겠습니다. 죄송합니다.

---

소

- **전자 서명에 활용되는 비대칭키 암호화에 대한 설명**

  송신자는 개인키를 사용하여 데이터를 암호화하고 전자 서명을 생성함. 수신자는 송신자의 공개키를 사용하여 전자 서명을 확인하여 데이터의 무결성과 송신자의 신원을 보장함



- **HTTP와 HTTPS의 차이점**



- **HTTPS의 통신흐름**



---

진

- **대칭키와 공개키에 대해 설명해주세요.**

  대칭키와 공개키는 암호화와 관련된 키(key)의 개념입니다. 이 두 가지 키는 암호화와 복호화에 사용되며, 데이터의 기밀성과 보안을 유지하기 위해 사용됩니다.

  1. 대칭키: 대칭키는 암호화와 복호화에 동일한 키를 사용하는 방식입니다. 키를 공유하는 사람들 사이에서만 암호화된 데이터를 전달할 수 있습니다.  암호화와 복호화가 빠르지만, 대칭키는 전달과정에서 해킹의 위험이 있어 공개키가 개발되었습니다.
  2. 공개키: 공개키는 암호화와 복호화에 서로 다른 키를 사용하는 방식입니다. 공개키로 데이터를 암호화하고, 복호화는 개인이 소유하고 있는 고유한 비밀키(private key)로만 가능하게 합니다. 이는 안전한 키 교환과 인증에 적용됩니다.

  

- **HTTPS 에 대해 설명해주세요.**

  일반 HTTP는 평문 텍스트로 데이터를 전송하기 때문에 중요한 데이터는 해거카 중간에서 데이터를 조회하거나 수정할 수 있습니다.

  이를 해결하기 위해, HTTP에 SSL 또는 TLS를 추가하여 공개키 방식으로 데이터를 암호화하여 통신하는 방식이 바로 HTTPS 통신 프로토콜입니다. HTTP는 80번 포트를 사용하고 HTTPS는 443번 포트를 사용합니다.

  

- **TSL과 SSL에 대해 설명해주세요.**

---



## 로드 밸런싱

# Blocking/Non-blocking & Synchronous/Asynchronous

# Blocking I/O & Non-Blocking I/O

부

- **로드 밸런싱(Load Balancing) 에 대해 말해보세요.**

  서버에 가해지는 부하를 적절하게 분산시켜주는 장치 또는 기술을 뜻합니다.

  

- **로드 밸런싱의 개념을 설명하고 늘어나는 서버 부하를 처리하기 위한 2가지 방법을 설명해주세요.** 
  서버에 가해지는 부하를 적절하게 분산시켜주는 장치 또는 기술을입니다. 

  서버 부하를 처리하기 위한 첫번째 방법으로는 기존에 갖고 있는 성능을 업그레이드하는 scale-up 방법과 

  두번째 방법으로는 여러대의 서버를 더 증설하는 scale-out 방법이 있습니다.



- **로드 밸런싱 알고리즘 중 대표적인 라운드 로빈, 최소 연결 방식 에 대해 설명해보세요.**

  라운드 로빈(Round Robin) 알고리즘은 **서버에 들어오는 요청들을 순서대로 돌아가면서 배정하는 알고리즘**입니다. 여러 대의 서버 성능이 비슷하고 세션이 오래 지속되지 않는 경우에 적합합니다.

  반면, 최소 연결 방식(Least Connection Method) 은 요청이 서버에 들어왔을 때 **가장 연결이 적은 서버에 배정하는 알고리즘**입니다. 서버 트래픽이 일정하지 않고 세션이 길어질 때 적합합니다.



- **Blocking과 Non-Blocking의 차이점**

  제어권이 어디에 있느냐에 대한 관점 차이다.

  블로킹은 A 함수가 B 함수를 호출 할 때, B 함수가 자신의 작업이 종료되기 전까지 A 함수에게 제어권을 돌려주지 않는 것이고

  논블로킹은 A 함수가 B 함수를 호출 할 때, B 함수가 제어권을 바로 A 함수에게 넘겨주면서, A 함수가 다른 일을 할 수 있도록 하는 것이다.

---



호

- **Blocking과 Synchronous의 개념 차이**

  블락킹은 실행흐름을 제어할 수 있는 제어권을 어떤 함수가 가지냐는 전체 작업의 흐름을 두고 얘기하는 것이고 동기는 요청한 작업의 완료 여부를 따지냐 안 따지냐가 중점이다.

  

- **Async-NonBlocking 예시**

  Js: Promise 객체 방식으로 요청에 응답을 받을 때 혹은 ajax로 응답을 받을 때 사용한다.

  

- **로드밸런싱 알고리즘 중 하나를 설명하시오**

  - round robin: 들어온 요청을 순서대로 배정하는 방식
  - weighted round robin: 각각의 서버마다 가중치를 매기고 가중치가 높은 서버에 요청을 우선 배분
  - IP hash: 클라이언트 IP 주소를 특정 서버로 매핑하여 요청을 처리
  - least connection: 가장 적은 연결 상태를 보이는 서버에 우선 배분
  - least response time: 연결상태와 응답 시간을 모두 고려해 가장 빨리 처리할 수 있는 서버로 배분

---

소

- 로드밸런싱의 대표적인 알고리즘에 대해 설명

  라운드로빈 방식, 최소연결 방식, IP 해시 방식 등이 있다.

  라운드로빈은 서버에 들어온 요청을 순서대로 돌아가며 배정하는 방식이며 여러 서버가 동일한 스펙을 가지고 서버와의 연결이 오래 지속되지 않는 경우에 적합하다.

  최소 연결 방식은 연결개수가 가장 적은 서버를 선택하는 방식이며 세션이 길어지거나 서버에 분배된 트래픽이 일정하지 않은 경우 적합하다.

  IP 해시 방식은 사용자의 IP를 고정된 길이의 데이터로 매핑하는 해싱 작업을 거쳐 요청을 처리하는 방식이며 특정 사용자가 항상 같은 서버로 연결되는 것을 보장한다.



- Blocking과 Synchronous의 차이점

  Blocking은 함수 호출시 제어권을 주는지에 대한 유무의 차이에 따르고, Synchronous는 특정 일을 요청해서 수행중일 때 그 상태나 결과를 신경쓰고 있는지에 따라 차이가 있다.



- 로드 밸런싱과 클러스터링의 차이

  로드밸런싱은 여러대의 서버에 트래픽을 균등하게 분산시키는 기술이고, 클러스터은 여러대의 서버를 하나의 서버로 만들어 사용하는 것

---

진

- **서버 확장의 두 가지 방법(Scale-Up, Scale-Out) 에 대해 설명해보세요.**

  **Scale-Up 방식은 서버 자체의 성능을 향상시키는 것**으로, 서버 CPU, RAM 등을 교체하여 서버의 성능을 향상시킵니다.

  반면, **Scale-Out 방식은 기존 서버와 동일하거나 낮은 서버를 여러 대 증설하여 운영하는 것**을 뜻합니다. 보통 Scale-Out 방식을 사용하는데, 그 이유는 서버 성능을 향상시키는 것보다 여러 대의 서버를 증설하는 것이 비용적 측면에서 효과적이기 때문입니다.



- **L4 로드 밸런싱과 L7 로드 밸런싱에 대해 설명하고, 차이를 말해보세요.**

  L4 로드 밸런싱은 **Layer 4**(네트워크 계층 또는 트랜스포트(전송) 계층) 의 정보를 바탕으로 트래픽을 분산하는 방식입니다. 즉, TCP, UDP, IP 정보들을 바탕으로 분산하는데요. 이는 정보가 어떻게 생겼는지 보지 않고 **패킷 레벨에서만 트래픽을 분산**하기 때문에 속도가 빠르고 효율성이 높습니다. 그리고 L7 로드 밸런싱보다 저렴합니다.

  반면, L7 로드 밸런싱은 **Layer 7**(애플리케이션(응용) 계층) 의 정보를 바탕으로 요청을 분산합니다. **HTTP Header, Cookie 등과 같이 사용자가 요청한 정보들을 바탕으로 트래픽을 분산**하기 때문에 섬세한 라우팅이 가능하고 비정상적인 트래픽을 판별할 수 있습니다. 하지만, L4 로드 밸런싱보다 비용이 높습니다.



- **Synchronous 와 Asynchronous 의 차이점**

  다른 작업의 일을 ‘신경쓰고 있는지’의 유무의 차이이다.

  함수 A와 B가 있다고 가정했을 때, B의 작업 완료 상태를 A가 신경쓰고 있는지 없는지의 차이라고 생각하면 된다.

  - **Synchronous** : 함수 A는 함수 B가 작업하는 것을 기다리면서, 현재 상태가 어떤지 계속 체크하며 작업 완료 여부를 물어본다.
  - **Asynchronous** : 함수 A는 함수 B의 수행 상태를 신경쓸 필요없이 B 혼자 작업하다가 완료가 되면 작업 완료를 알려준다. (Callback)