

# TCP/IP (흐름제어, 혼잡제어)

- OSI 7 계층 참고 모델이 존재하지만 엄연히 참고 모델, 권고 사항일 뿐 실제 사용되는 인터넷 프로토콜은

7계층 구조를 완전히 따르진 않는다. 

- 인터넷 프로토콜 스택( Internet Protocol Stack )은 현재 대부분 TCP/IP를 따른다.
- 즉, TCP/IP는 OSI 7 Layer처럼 **추상적인 레이어 역할**을 하는 것이 아닌 **실용적인 네트워크 연결**을 위해 만들어졌다.

![img](https://velog.velcdn.com/images%2Faverycode%2Fpost%2F01f46d6e-a577-41e7-b99f-31d67a512ce0%2Fimage.png)



## TCP/IP의 개념

- 데이터가 의도된 목적지에 닿을 수 있도록 보장해주는 통신 규약이다.
- TCP와 IP 두가지의 프로토콜로 이루어져 있다.
- TCP는 전송 데이터를 일정 단위로 나누고 포장하는 것에 관한 규약이고, IP는 직접 데이터를 주고 받는 것에 관한 규약이다. 

-  TCP / IP를 사용하겠다는 것은 IP 주소 체계를 따르고, IP Routing을 이용해 송수신자의 네트워크 주소를 설정하는 것이다. 그리고 TCP의 특성 즉 패킷을 통해서 IP 간의 논리적 연결을 생성하고 신뢰할 수 있는 데이터 교환을 하겠다는 의미이다.
- 즉, TCP/IP를 사용한다는 것은 송신자가 수신자에게 IP 주소를 사용하여 데이터를 전달하고, 그 데이터가 제대로 갔는지, 너무 빠르지는 않는지, 제대로 받았다고 연락은 오는지에 대해서는 TCP가 그 역할을 수행하는 네트워크 통신 방법을 사용하고 있다는 의미



## TCP (Transmission Control Protocol) 통신이란?

- 네트워크 통신에서 신뢰적인 연결방식
- 패킷 교환 방식 네트워크에서 패킷들이 안전하게 이동할 수 있도록 보장해주는 프로토콜
- 흐름제어, 혼잡제어 동작을 수행한다.



## 흐름제어 (Flow Control)

**송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위한 기법**

- 수신측이 너무 많은 패킷을 수신받지 않도록 하기 위함이다.

- 수신측에는 패킷을 수신받는 버퍼의 크기가 정해져있는데, 만약 송신측의 전송 속도가 너무 빨라 한 번에 수많은 패킷을 수신받아버린다면, 버퍼가 가득차 손실되는 패킷들이 발생할 것이다.
- 수신측이 송신측보다 데이터 처리 속도가 빠르면 문제없지만, 송신측의 속도가 빠를 경우 문제가 생긴다.
- 이러한 위험을 줄이기 위해 송신 측의 데이터 전송량을 수신측에 따라 조절해야한다.



## 패킷 전송 과정

우선, TCP/IP 계층에 의거하여 **패킷이 전송되는 과정**을 간략히 살펴보자.

1. **Application** Layer : 송신측 Application Layer 가 소켓에 데이터를 입력

2. **Transport** Layer : 데이터를 세그먼트로 감싸고 Network Layer 에 전달

3. **수신측 노드**로 세그먼트가 **전송**됨. 동시에 **송신측의 Send Buffer 와 수신측의 Receive Buffer 각각에 데이터가 저장**됨.

4. **수신측 Application Layer** 에서 준비가 되면, R**eceive Buffer 에 있는 데이터를 읽기** 시작함

5. **따라서, Receive Buffer 가 넘쳐나지 않도록 하는 것이 흐름 제어의 핵심!**

   → 이를 위해 RWND(Receive Window, Receive Buffer 의 남은 공간) 을 송신측에 계속하여 피드백함



## 흐름제어 기법 종류

### 1. Stop and Wait 

- 매번 전송한 패킷에 대한 확인 응답을 받아야만 그 다음 패킷을 전송하는 기법

![img](https://t1.daumcdn.net/cfile/tistory/263B7D4E5715ECEB32)

### 2. Sliding Window (Go Back N ARQ)

수신측에서 설정한 윈도우 크기만큼 송신측에서 확인응답없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 제어 기법

- 전송은 되었으나, ACK 을 받지 못한 Byte 크기를 파악하기 위해 사용 한다

- LastByteSent - LastByteAcked ≤ ReceivecWindowAdvertised

  (마지막에 보내진 바이트 - 마지막에 확인된 바이트 <= 버퍼 남은 공간)

  (현재 이도저도 못하고 있는 패킷 수  ≤  슬라이딩 윈도우 크기)



- **동작방식** : 먼저 윈도우에 포함되는 모든 패킷을 전송하고, 그 패킷들의 전달이 확인되는대로 해당 윈도우를 옆으로 옮김으로써 그 다음 패킷을 전송하는 방식으로 동작한다.

  ![img](https://t1.daumcdn.net/cfile/tistory/253F7E485715ED5F27)

- **Window** : TCP/IP를 사용하는 모든 호스트들은 송신하기 위한 것과 수신하기 위한 2개의 Window를 가지고 있다. 호스트들은 실제 데이터를 보내기 전에 3 Way Handshake 를 통해 연결 설정을 해줄 때 수신 호스트의 Receive Window 크기에 자신의 Send Window 크기를 맞춰 설정한다.



#### 세부구조

1. ##### 송신 버퍼

   ![img](https://t1.daumcdn.net/cfile/tistory/22532F485715EDF218)

   - 200 이전의 바이트는 이미 전송되었고, 확인응답을 받은 상태
   - 200 ~ 202 바이트는 전송되었으나 확인응답을 받지 못한 상태
   - 203~211 바이트는 아직 전송이 되지 않은 상태

   

2. ##### 수신 윈도우

   ![img](https://t1.daumcdn.net/cfile/tistory/25403A485715EE362B)

3. ##### 송신 윈도우

   ![img](https://t1.daumcdn.net/cfile/tistory/2520244B5715EE6A14)

   - 수신 윈도우보다 작거나 같은 크기로 송신 윈도우를 지정하게되면 흐름제어가 가능하다.

4. ##### 송신 윈도우 슬라이딩 (이동)

   ![img](https://t1.daumcdn.net/cfile/tistory/227DC8505715EEBA0A)

   - Before 에서 203~204를 전송하면 수신측에서는 확인응답 203을 보내고, 송신측은 이를 받아 After 상태와 같이 송신 윈도우를 203~209로 이동함
   - After 는 205~209가 전송 가능한 상태



## 혼잡제어 (Congestion Control)

- 송신측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달된다. 만약 한 라우터에 데이터가 몰릴 경우, 자신에게 온 데이터를 모두 처리할 수 없게 된다. 이런 경우 호스트들은 또 다시 재전송을 하게되고 결국 혼잡만 가중시켜 오버플로우나 데이터 손신을 발생시키게 된다. 따라서 이러한 네트워크의 혼잡을 피하기 우해 송신측에서 보내는 데이터의 전송속도를 강제로 줄이게 되는데, 이러한 작업을 혼잡제어라고 한다.
- 또한 네트워크 내에 패킷의 수가 과도하게 증가하는 현상을 혼잡이라 하며, 혼잡 현상을 방지하거나 제거하는 기능을 **혼잡제어**라고 한다.
- 흐름제어가 송신측과 수신측 사이의 전송속도를 다루는데 반해, 혼잡제어는 호스트와 라우터를포함한 보다 넓은 관점에서 전송 문제를 다루게 된다.



## 혼잡제어 기법 종류

![img](https://t1.daumcdn.net/cfile/tistory/256E39425715F10103)

- #### AIMD(Additive Increase / Multiplicative Decrease)

  - 처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 window 크기(단위 시간 내에 보내는 패킷의 수)를 1씩 증가시켜가며 전송하는 방법
  - 패킷 전송에 실패하거나 일정 시간을 넘으면 패킷의 보내는 속도를 절반으로 줄인다.
  - 공평한 방식으로, 여러 호스트가 한 네트워크를 공유하고 있으면 나중에 진입하는 쪽이 처음에는 불리하지만, 시간이 흐르면 평형상태로 수렴하게 되는 특징이 있다.
  - 문제점은 초기에 네트워크의 높은 대역폭을 사용하지 못하여 오랜 시간이 걸리게 되고, 네트워크가 혼잡해지는 상황을 미리 감지하지 못한다. 즉, 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식이다.

- #### Slow Start (느린 시작)

  - AIMD 방식이 네트워크의 수용량 주변에서는 효율적으로 작동하지만, 처음에 전송 속도를 올리는데 시간이 오래 걸리는 단점이 존재했다.
  - Slow Start 방식은 AIMD와 마찬가지로 패킷을 하나씩 보내면서 시작하고, 패킷이 문제없이 도착하면 각각의 ACK 패킷마다 window size를 1씩 늘려준다. 즉, 한 주기가 지나면 window size가 2배로 된다.
  - 전송속도는 AIMD에 반해 지수 함수 꼴로 증가한다. 대신에 혼잡 현상이 발생하면 window size를 1로 떨어뜨리게 된다.
  - 처음에는 네트워크의 수용량을 예상할 수 있는 정보가 없지만, 한번 혼잡 현상이 발생하고 나면 네트워크의 수용량을 어느 정도 예상할 수 있다.
  - 그러므로 혼잡 현상이 발생하였던 window size의 절반까지는 이전처럼 지수 함수 꼴로 창 크기를 증가시키고 그 이후부터는 완만하게 1씩 증가시킨다.

- #### Fast Retransmit (빠른 재전송)

  - 빠른 재전송은 TCP의 혼잡 조절에 추가된 정책이다.
  - 패킷을 받는 쪽에서 먼저 도착해야할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK 패킷을 보내게 된다.
  - 단, 순서대로 잘 도착한 마지막 패킷의 다음 패킷의 순번을 ACK 패킷에 실어서 보내게 되므로, 중간에 하나가 손실되게 되면 송신 측에서는 순번이 중복된 ACK 패킷을 받게 된다. 이것을 감지하는 순간 문제가 되는 순번의 패킷을 재전송 해줄 수 있다.
  - 중복된 순번의 패킷을 3개 받으면 재전송을 하게 된다. 약간 혼잡한 상황이 일어난 것이므로 혼잡을 감지하고 window size를 줄이게 된다.

- #### Fast Recovery (빠른 회복)

  - 혼잡한 상태가 되면 window size를 1로 줄이지 않고 반으로 줄이고 선형증가시키는 방법이다. 이 정책까지 적용하면 혼잡 상황을 한번 겪고 나서부터는 순수한 AIMD 방식으로 동작하게 된다.

---

참고자료

https://velog.io/@rosewwross/TCPIP

https://aws-hyoh.tistory.com/entry/TCPIP-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0

https://terms.naver.com/entry.naver?docId=19019&cid=43659&categoryId=43659

https://doh-an.tistory.com/29

https://velog.io/@haero_kim/TCP-%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4-%EA%B8%B0%EB%B2%95-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0